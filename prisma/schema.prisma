generator client {
  provider        = "prisma-client-js"
  output          = "../node_modules/.prisma/client"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

/// Agent memory store for per-token AI context/state
model agent_memory {
  token_address      String   @id @db.VarChar(44)
  schema_version     String   @default("v1")
  interactions_count Int      @default(0)
  digest_latest      String?  @db.Text
  data               Json     @default("{}")
  created_at         DateTime @default(now()) @db.Timestamptz(6)
  updated_at         DateTime @default(now()) @db.Timestamptz(6)

  @@map("agent_memory")
}

/// Final AI analyses for tokens (persisted JSON output)
model ai_token_analyses {
  id              Int      @id @default(autoincrement())
  token_address   String   @db.VarChar(44)
  created_at      DateTime @default(now()) @db.Timestamptz(6)
  model           String?
  api             String?
  tool_calls_made Int?
  timings         Json?
  web_search_used Boolean?
  web_citations   Json?
  token_type      String?
  branch_score    Int?
  risk_score      Int?
  summary         String?  @db.Text
  project_summary String?  @db.Text
  file_path       String?
  analysis_json   Json

  @@index([token_address, created_at])
  @@map("ai_token_analyses")
}

model contest_participants {
  id                    Int                         @id @default(autoincrement())
  contest_id            Int
  wallet_address        String                      @db.VarChar(44)
  joined_at             DateTime                    @default(now()) @db.Timestamptz(6)
  initial_dxd_points    Decimal?                    @default(0) @db.Decimal(20, 0)
  current_dxd_points    Decimal?                    @default(0) @db.Decimal(20, 0)
  rank                  Int?
  prize_amount          Decimal?                    @db.Decimal(20, 8)
  prize_paid_at         DateTime?                   @db.Timestamptz(6)
  refund_amount         Decimal?                    @db.Decimal(20, 8)
  refunded_at           DateTime?                   @db.Timestamptz(6)
  refund_transaction_id Int?
  entry_transaction_id  Int?
  entry_time            DateTime                    @default(now()) @db.Timestamptz(6)
  final_rank            Int?
  prize_transaction_id  Int?
  status                String                      @default("active")
  portfolio_value       Decimal?                    @default(0) @db.Decimal(20, 8)
  initial_balance       Decimal?                    @default(0) @db.Decimal(20, 8)
  contests              contests                    @relation(fields: [contest_id], references: [id], onDelete: Cascade)
  entry_transaction     transactions?               @relation("contest_participants_entry_transaction_idTotransactions", fields: [entry_transaction_id], references: [id])
  prize_transaction     transactions?               @relation("contest_participants_prize_transaction_idTotransactions", fields: [prize_transaction_id], references: [id])
  refund_transaction    transactions?               @relation("contest_participants_refund_transaction_idTotransactions", fields: [refund_transaction_id], references: [id])
  users                 users                       @relation(fields: [wallet_address], references: [wallet_address])
  portfolio_history     contest_portfolio_history[]
  contest_portfolios    contest_portfolios[]        @relation("ParticipantPortfolios")

  @@unique([contest_id, wallet_address])
  @@index([wallet_address])
  @@index([status])
  @@index([portfolio_value])
  @@map("contest_participants")
}

model contest_portfolios {
  id             Int                   @id @default(autoincrement())
  contest_id     Int
  wallet_address String                @db.VarChar(44)
  token_id       Int
  weight         Int
  created_at     DateTime              @default(now()) @db.Timestamptz(6)
  quantity       Decimal               @db.Decimal(20, 8)
  contests       contests              @relation(fields: [contest_id], references: [id], onDelete: Cascade)
  tokens         tokens                @relation(fields: [token_id], references: [id])
  users          users                 @relation(fields: [wallet_address], references: [wallet_address])
  participant    contest_participants? @relation("ParticipantPortfolios", fields: [contest_id, wallet_address], references: [contest_id, wallet_address])

  @@unique([contest_id, wallet_address, token_id])
  @@index([wallet_address])
  @@index([token_id])
  @@map("contest_portfolios")
}

model contest_templates {
  id                  Int                @id @default(autoincrement())
  name                String
  description         String?
  duration_minutes    Int?
  entry_fee           Decimal?           @default(0) @db.Decimal(20, 0)
  min_participants    Int?               @default(3)
  max_participants    Int?               @default(100)
  allowed_buckets     Int[]              @default([1, 2, 3, 4, 5, 6, 7, 8, 9])
  default_payout_type String?            @default("top_heavy") @db.VarChar(20)
  visibility          String?            @default("public") @db.VarChar(20)
  bucket_requirements Json?              @default("{}")
  scoring_rules       Json?              @default("{}")
  is_active           Boolean?           @default(true)
  created_at          DateTime?          @default(now()) @db.Timestamptz(6)
  schedule            contest_schedule[]

  @@index([name], map: "idx_contest_templates_name")
  @@map("contest_templates")
}

model contest_token_buckets {
  contest_id Int
  token_id   Int
  bucket_id  Int
  contests   contests @relation(fields: [contest_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  tokens     tokens   @relation(fields: [token_id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@id([contest_id, token_id, bucket_id])
  @@index([contest_id], map: "idx_contest_token_buckets_contest")
  @@index([token_id], map: "idx_contest_token_buckets_token")
  @@map("contest_token_buckets")
}

model contest_token_performance {
  id             Int      @id @default(autoincrement())
  contest_id     Int
  wallet_address String   @db.VarChar(44)
  token_id       Int
  profit_loss    Decimal  @default(0) @db.Decimal(20, 8)
  timestamp      DateTime @default(now()) @db.Timestamptz(6)
  contests       contests @relation(fields: [contest_id], references: [id], onDelete: Cascade)
  tokens         tokens   @relation(fields: [token_id], references: [id])
  users          users    @relation(fields: [wallet_address], references: [wallet_address])

  @@index([contest_id])
  @@index([wallet_address])
  @@index([token_id])
  @@map("contest_token_performance")
}

model contest_token_prices {
  id             Int      @id @default(autoincrement())
  contest_id     Int
  wallet_address String   @db.VarChar(44)
  token_id       Int
  amount         Decimal  @default(0) @db.Decimal(20, 0)
  price          Decimal  @db.Decimal(20, 8)
  timestamp      DateTime @default(now()) @db.Timestamptz(6)
  contests       contests @relation(fields: [contest_id], references: [id], onDelete: Cascade)
  tokens         tokens   @relation(fields: [token_id], references: [id])
  users          users    @relation(fields: [wallet_address], references: [wallet_address])

  @@index([contest_id])
  @@index([wallet_address])
  @@index([token_id])
  @@map("contest_token_prices")
}

model contest_portfolio_trades {
  id             Int       @id @default(autoincrement())
  contest_id     Int
  wallet_address String    @db.VarChar(44)
  token_id       Int
  type           TradeType
  old_weight     Int
  new_weight     Int
  price_at_trade Decimal   @db.Decimal(20, 8)
  virtual_amount Decimal   @db.Decimal(20, 0)
  executed_at    DateTime  @default(now()) @db.Timestamptz(6)
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  contests       contests  @relation(fields: [contest_id], references: [id], onDelete: Cascade)
  tokens         tokens    @relation(fields: [token_id], references: [id])
  users          users     @relation(fields: [wallet_address], references: [wallet_address])

  @@index([contest_id])
  @@index([wallet_address])
  @@index([token_id])
  @@map("contest_portfolio_trades")
}

model contest_portfolio_history {
  id                     Int                  @id @default(autoincrement())
  contest_participant_id Int
  timestamp              DateTime             @db.Timestamptz(6)
  portfolio_value        Decimal              @db.Decimal(20, 8)
  participant            contest_participants @relation(fields: [contest_participant_id], references: [id], onDelete: Cascade)

  @@index([contest_participant_id, timestamp])
  @@map("contest_portfolio_history")
}

model contest_chat_messages {
  id                    Int      @id @default(autoincrement())
  contest_id            Int
  sender_wallet_address String   @db.VarChar(44)
  message_text          String
  created_at            DateTime @default(now()) @db.Timestamptz(6)
  contest               contests @relation(fields: [contest_id], references: [id], onDelete: Cascade)
  sender                users    @relation(fields: [sender_wallet_address], references: [wallet_address])

  @@index([contest_id, created_at])
  @@map("contest_chat_messages")
}

model general_chat_messages {
  id                    Int      @id @default(autoincrement())
  sender_wallet_address String   @db.VarChar(44)
  message_text          String
  created_at            DateTime @default(now()) @db.Timestamptz(6)
  sender                users    @relation(fields: [sender_wallet_address], references: [wallet_address])

  @@index([created_at])
  @@map("general_chat_messages")
}

model contests {
  id                        Int                         @id @default(autoincrement())
  contest_code              String                      @unique
  token_mint                String?                     @db.VarChar(44)
  name                      String
  description               String?
  start_time                DateTime                    @db.Timestamptz(6)
  end_time                  DateTime                    @db.Timestamptz(6)
  entry_fee                 Decimal?                    @default(0) @db.Decimal(20, 8)
  prize_pool                Decimal                     @default(0) @db.Decimal(20, 8)
  current_prize_pool        Decimal                     @default(0) @db.Decimal(20, 8)
  status                    contest_status              @default(pending)
  payout_type               String?                     @db.VarChar(20)
  settings                  Json?                       @default("{}")
  created_at                DateTime                    @default(now()) @db.Timestamptz(6)
  allowed_buckets           Int[]
  participant_count         Int                         @default(0)
  min_participants          Int                         @default(2)
  max_participants          Int?
  cancelled_at              DateTime?                   @db.Timestamptz(6)
  completed_at              DateTime?                   @db.Timestamptz(6)
  cancellation_reason       String?
  image_url                 String?
  image_prompt              String?
  image_headliner_token_ca  Json?
  schedule_id               Int?
  created_by_user           String?                     @db.VarChar(44)
  creator_credit_used       Int?
  visibility                String                      @default("public") @db.VarChar(20)
  challenge_expires_at      DateTime?                   @db.Timestamptz(6)
  challenge_status          challenge_status?
  challenged_wallet         String?                     @db.VarChar(44)
  challenger_wallet         String?                     @db.VarChar(44)
  contest_type              contest_type                @default(REGULAR)
  ai_decisions              ai_decisions[]
  blockchain_transactions   blockchain_transactions[]
  chat_messages             contest_chat_messages[]
  contest_participants      contest_participants[]
  contest_portfolio_trades  contest_portfolio_trades[]
  contest_portfolios        contest_portfolios[]
  contest_token_buckets     contest_token_buckets[]
  contest_token_performance contest_token_performance[]
  contest_token_prices      contest_token_prices[]
  contest_wallets           contest_wallets?
  creator                   users?                      @relation("ContestCreator", fields: [created_by_user], references: [wallet_address])
  creation_credit           contest_creation_credits?   @relation(fields: [creator_credit_used], references: [id])
  schedule                  contest_schedule?           @relation(fields: [schedule_id], references: [id])
  pending_entries           pending_contest_entries[]   @relation("ContestPendingEntries")
  transactions              transactions[]
  vanity_wallet             vanity_wallet_pool?
  token_creation_vouchers   token_creation_vouchers[]

  @@index([status])
  @@index([start_time])
  @@index([end_time])
  @@index([visibility])
  @@index([created_by_user])
  @@map("contests")
}

model token_bucket_memberships {
  bucket_id     Int
  token_id      Int
  token_buckets token_buckets @relation(fields: [bucket_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  tokens        tokens        @relation(fields: [token_id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@id([bucket_id, token_id])
  @@index([token_id], map: "idx_token_bucket_memberships_token")
  @@map("token_bucket_memberships")
}

model token_buckets {
  id                       Int                        @id @default(autoincrement())
  bucket_code              String                     @unique(map: "unique_token_bucket_code")
  name                     String
  description              String?
  created_at               DateTime?                  @default(now()) @db.Timestamptz(6)
  token_bucket_memberships token_bucket_memberships[]

  @@index([bucket_code], map: "idx_token_buckets_code")
  @@map("token_buckets")
}

model token_prices {
  token_id   Int       @id
  price      Decimal?  @db.Decimal(20, 8)
  updated_at DateTime? @default(now()) @db.Timestamptz(6)
  change_24h Decimal?  @db.Decimal(20, 8)
  fdv        Decimal?  @db.Decimal(20, 0)
  liquidity  Decimal?  @db.Decimal(20, 0)
  market_cap Decimal?  @db.Decimal(20, 0)
  volume_24h Decimal?  @db.Decimal(20, 0)
  tokens     tokens    @relation(fields: [token_id], references: [id], onDelete: Cascade)

  @@index([updated_at(sort: Desc)], map: "idx_token_prices_updated")
  @@index([market_cap(sort: Desc), volume_24h(sort: Desc), liquidity(sort: Desc)], map: "idx_token_prices_hot_tokens")
  @@index([change_24h(sort: Desc)], map: "idx_token_prices_change_desc")
  @@index([volume_24h(sort: Desc)], map: "idx_token_prices_volume_desc")
  @@map("token_prices")
}

model token_price_history {
  id        Int      @id @default(autoincrement())
  token_id  Int
  price     Decimal  @db.Decimal(20, 8)
  source    String?  @db.VarChar(50)
  timestamp DateTime @default(now()) @db.Timestamptz(6)
  tokens    tokens   @relation(fields: [token_id], references: [id], onDelete: Cascade)

  @@index([token_id])
  @@index([timestamp(sort: Desc)])
  @@index([token_id, timestamp(sort: Desc)])
  @@map("token_price_history")
}

model tokens {
  id                           Int                         @id @default(autoincrement())
  address                      String                      @unique(map: "unique_token_address")
  symbol                       String?
  name                         String?
  decimals                     Int?                        @default(9)
  is_active                    Boolean                     @default(false)
  created_at                   DateTime?                   @default(now()) @db.Timestamptz(6)
  image_url                    String?
  description                  String?
  color                        String?                     @default("#888888")
  updated_at                   DateTime?                   @updatedAt @db.Timestamptz(6)
  coingeckoId                  String?
  tags                         Json?
  last_price_change            DateTime?
  last_refresh_attempt         DateTime?
  last_refresh_success         DateTime?
  priority_score               Int                         @default(0)
  refresh_interval_seconds     Int                         @default(30)
  refresh_metadata             Json?                       @default("{}")
  raw_supply                   BigInt?
  total_supply                 Decimal?                    @db.Decimal(38, 18)
  discovery_count              Int?                        @default(0)
  metadata_status              String?                     @default("pending")
  last_priority_calculation    DateTime?
  header_image_url             String?
  open_graph_image_url         String?
  first_seen_on_jupiter_at     DateTime?                   @default(now()) @db.Timestamptz(6)
  last_is_active_evaluation_at DateTime?
  last_jupiter_sync_at         DateTime?                   @updatedAt
  manually_activated           Boolean                     @default(false)
  metadata_last_updated_at     DateTime?
  degenduel_score              Decimal?                    @default(0) @db.Decimal(20, 8)
  score_calculated_at          DateTime?                   @db.Timestamptz(6)
  trend_category               String?                     @default("Active") @db.VarChar(50)
  momentum_indicator           String?                     @default("stable") @db.VarChar(50)
  source                       String?                     @db.VarChar(50)
  launchpad                    String?                     @db.VarChar(50)
  // 🚀 REVOLUTIONARY POOL-DERIVED PRICING FIELDS
  pool_derived_price           Decimal?                    @db.Decimal(20, 10)
  pool_derived_volume_24h      Decimal?                    @db.Decimal(20, 2)
  pool_derived_liquidity       Decimal?                    @db.Decimal(20, 2)
  pool_derived_market_cap      Decimal?                    @db.Decimal(20, 2)
  price_calculation_method     String?                     @db.VarChar(50)
  pool_price_calculated_at     DateTime?                   @db.Timestamptz(6)
  ai_decisions                 ai_decisions[]
  contest_portfolio_trades     contest_portfolio_trades[]
  contest_portfolios           contest_portfolios[]
  contest_token_buckets        contest_token_buckets[]
  contest_token_performance    contest_token_performance[]
  contest_token_prices         contest_token_prices[]
  monitored_tokens             monitored_tokens?
  pool_price_changes           pool_price_changes[]
  token_bucket_memberships     token_bucket_memberships[]
  liquidity_history            token_liquidity_history[]
  market_cap_history           token_market_cap_history[]
  pools                        token_pools[]
  price_history                token_price_history[]
  token_prices                 token_prices?
  rank_history                 token_rank_history[]
  token_socials                token_socials[]
  volume_history               token_volume_history[]
  token_websites               token_websites[]

  @@index([symbol], map: "idx_tokens_symbol")
  @@index([degenduel_score(sort: Desc)], map: "idx_tokens_degenduel_score")
  @@index([is_active, degenduel_score(sort: Desc)], map: "idx_tokens_active_score")
  @@index([trend_category], map: "idx_tokens_trend_category")
  @@index([is_active, metadata_status, degenduel_score(sort: Desc)], map: "idx_tokens_common_query")
  @@map("tokens")
}

model transactions {
  id                                                                            Int                        @id @default(autoincrement())
  wallet_address                                                                String?
  type                                                                          transaction_type
  amount                                                                        Decimal                    @db.Decimal(20, 8)
  balance_before                                                                Decimal                    @db.Decimal(20, 8)
  balance_after                                                                 Decimal                    @db.Decimal(20, 8)
  contest_id                                                                    Int?
  description                                                                   String?
  status                                                                        transaction_status?        @default(completed)
  metadata                                                                      Json?                      @default("{}")
  created_at                                                                    DateTime?                  @default(now()) @db.Timestamptz(6)
  processed_at                                                                  DateTime?                  @db.Timestamptz(6)
  contest_participants_contest_participants_entry_transaction_idTotransactions  contest_participants[]     @relation("contest_participants_entry_transaction_idTotransactions")
  contest_participants_contest_participants_prize_transaction_idTotransactions  contest_participants[]     @relation("contest_participants_prize_transaction_idTotransactions")
  contest_participants_contest_participants_refund_transaction_idTotransactions contest_participants[]     @relation("contest_participants_refund_transaction_idTotransactions")
  referral_rewards                                                              referral_rewards[]
  dividend_payments                                                             duel_token_daily_balance[]
  airdrops                                                                      airdrops[]
  contests                                                                      contests?                  @relation(fields: [contest_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  users                                                                         users?                     @relation(fields: [wallet_address], references: [wallet_address], onDelete: NoAction, onUpdate: NoAction)

  @@index([contest_id], map: "idx_transactions_contest")
  @@index([type, created_at], map: "idx_transactions_type_created")
  @@index([wallet_address], map: "idx_transactions_wallet")
  @@map("transactions")
}

model user_achievements {
  id               Int       @id @default(autoincrement())
  wallet_address   String?
  achievement_type String
  value            Json?     @default("{}")
  achieved_at      DateTime? @default(now()) @db.Timestamptz(6)
  tier             String    @default("BRONZE") @db.VarChar(20)
  category         String    @default("CONTESTS") @db.VarChar(20)
  xp_awarded       Int       @default(0)
  context          Json?     @default("{}")
  user             users?    @relation(fields: [wallet_address], references: [wallet_address], onUpdate: NoAction)

  @@index([wallet_address], map: "idx_user_achievements_wallet")
  @@index([achievement_type], map: "idx_user_achievements_type")
  @@index([category], map: "idx_user_achievements_category")
  @@index([tier], map: "idx_user_achievements_tier")
  @@map("user_achievements")
}

model user_social_profiles {
  wallet_address    String
  platform          String
  platform_user_id  String
  username          String
  verified          Boolean?  @default(false)
  verification_date DateTime? @db.Timestamptz(6)
  last_verified     DateTime? @db.Timestamptz(6)
  metadata          Json?     @default("{}")
  created_at        DateTime? @default(now()) @db.Timestamptz(6)
  updated_at        DateTime? @default(now()) @db.Timestamptz(6)
  user              users     @relation(fields: [wallet_address], references: [wallet_address], onDelete: Cascade)

  @@id([wallet_address, platform])
  @@unique([platform, platform_user_id], map: "unique_platform_user")
  @@index([platform, platform_user_id], map: "idx_user_social_profiles_platform")
  @@map("user_social_profiles")
}

model user_stats {
  wallet_address    String    @id
  contests_entered  Int?      @default(0)
  contests_won      Int?      @default(0)
  total_prize_money Decimal?  @default(0) @db.Decimal(20, 0)
  best_score        Decimal?  @db.Decimal(10, 2)
  avg_score         Decimal?  @db.Decimal(10, 2)
  last_updated      DateTime? @default(now()) @db.Timestamptz(6)
  users             users     @relation(fields: [wallet_address], references: [wallet_address], onDelete: NoAction, onUpdate: NoAction)

  @@index([wallet_address], map: "idx_user_stats_wallet")
  @@map("user_stats")
}

model user_token_stats {
  wallet_address       String
  token_address        String
  times_picked         Int?     @default(0)
  wins_with_token      Int?     @default(0)
  avg_score_with_token Decimal? @db.Decimal(10, 2)

  @@id([wallet_address, token_address])
  @@index([wallet_address], map: "idx_user_token_stats_wallet")
  @@index([token_address], map: "idx_user_token_stats_token")
  @@map("user_token_stats")
}

model users {
  id                         Int                          @id @default(autoincrement())
  wallet_address             String                       @unique
  username                   String?                      @unique
  email                      String?                      @unique
  nickname                   String?
  role                       UserRole                     @default(user)
  user_level_id              Int?
  created_at                 DateTime?                    @default(now()) @db.Timestamptz(6)
  updated_at                 DateTime?                    @db.Timestamptz(6)
  last_login                 DateTime?                    @db.Timestamptz(6)
  total_contests             Int?                         @default(0)
  is_banned                  Boolean                      @default(false)
  ban_reason                 String?
  referral_code              String?                      @unique @db.VarChar(20)
  referred_by_code           String?                      @db.VarChar(20)
  experience_points          Int                          @default(0)
  last_level_up              DateTime?                    @db.Timestamptz(6)
  profile_image_url          String?                      @default("/images/profiles/default_pic_green.png")
  profile_image_updated_at   DateTime?                    @db.Timestamptz(6)
  last_balance_check         DateTime?                    @db.Timestamptz(6)
  last_known_balance         BigInt?
  is_ai_agent                Boolean                      @default(false)
  mcp_token                  String?                      @unique
  mcp_token_created_at       DateTime?                    @db.Timestamptz(6)
  mcp_token_last_used        DateTime?                    @db.Timestamptz(6)
  degen_token_balance        BigInt?                      @default(0)
  whale_status               Boolean                      @default(false)
  whale_tier                 String?                      @db.VarChar(20)
  legend_status              Boolean                      @default(false)
  last_balance_update        DateTime?                    @db.Timestamptz(6)
  bio                        String?                      @db.Text
  line_design                Json?                        @default("{}")
  admin_label                String?                      @db.VarChar(255)
  ai_conversations           ai_conversations[]           @relation("UserAIConversations")
  authorized_devices         authorized_devices[]         @relation("UserAuthorizedDevices")
  biometric_auth_challenges  biometric_auth_challenges[]
  biometric_credentials      biometric_credentials[]
  client_errors              client_errors[]
  sent_chat_messages         contest_chat_messages[]
  sent_general_chat_messages general_chat_messages[]
  contest_credits            contest_creation_credits[]   @relation("UserContestCredits")
  contest_participants       contest_participants[]
  contest_portfolio_trades   contest_portfolio_trades[]
  contest_portfolios         contest_portfolios[]
  contest_token_performance  contest_token_performance[]
  contest_token_prices       contest_token_prices[]
  created_contests           contests[]                   @relation("ContestCreator")
  owned_managed_wallets      managed_wallets[]            @relation("ManagedWalletOwner")
  participant_influences     participant_influences[]
  pending_contest_entries    pending_contest_entries[]    @relation("UserPendingContestEntries")
  qr_auth_sessions           qr_auth_sessions[]           @relation("UserQrAuthSessions")
  referral_clicks            referral_clicks[]            @relation("ReferralClicksReceived")
  referral_milestones        referral_milestones[]
  referral_rankings          referral_period_rankings[]
  referral_rewards           referral_rewards[]
  referred_by                referrals[]                  @relation("ReferredByRelation")
  referrals_made             referrals[]                  @relation("ReferralsMadeRelation")
  refresh_tokens             refresh_tokens[]
  transactions               transactions[]
  user_achievements          user_achievements[]
  ip_history                 user_ip_history[]
  privileges                 user_privileges[]
  social_profiles            user_social_profiles[]
  user_stats                 user_stats?
  user_level                 user_levels?                 @relation(fields: [user_level_id], references: [id])
  wallet_balances            wallet_balance_history[]
  duel_token_balances        duel_token_balance_history[]
  duel_token_daily_balances  duel_token_daily_balance[]
  websocket_messages         websocket_messages[]
  whale_status_history       whale_status_history[]
  user_line_skins            user_line_skins[]
  airdrops                   airdrops[]
  user_metadata              user_metadata?
  token_holder_snapshots     token_holder_snapshots[]
  token_creation_vouchers    token_creation_vouchers[]
  launched_tokens            user_launched_tokens[]
  api_keys                   api_keys[]

  @@index([wallet_address], map: "idx_users_wallet")
  @@index([username], map: "idx_users_username")
  @@index([role], map: "idx_users_role")
  @@index([experience_points(sort: Desc)], map: "idx_users_experience_points")
  @@map("users")
}

model user_metadata {
  id            Int      @id @default(autoincrement())
  user_id       Int      @unique
  admin_notes   String?  @db.Text
  risk_level    String? // "low", "medium", "high"
  kyc_status    String? // "pending", "verified", "rejected"
  internal_tags Json? // ["whale", "market_maker", "suspicious"]
  custom_data   Json? // Any other data you want
  created_at    DateTime @default(now()) @db.Timestamptz(6)
  updated_at    DateTime @updatedAt @db.Timestamptz(6)

  user users @relation(fields: [user_id], references: [id])

  @@index([user_id])
  @@map("user_metadata")
}

model admin_logs {
  id            Int      @id @default(autoincrement())
  admin_address String   @db.VarChar
  action        String   @db.VarChar
  details       Json     @default("{}")
  created_at    DateTime @default(now()) @db.Timestamptz(6)
  ip_address    String?  @db.VarChar
  user_agent    String?  @db.VarChar

  @@index([admin_address], map: "idx_admin_logs_admin")
  @@index([created_at], map: "idx_admin_logs_created")
  @@map("admin_logs")
}

model ai_agents {
  id             Int            @id @default(autoincrement())
  name           String         @db.VarChar
  personality    String         @db.VarChar
  risk_tolerance Int
  expertise      String[]       @db.VarChar
  created_at     DateTime       @default(now()) @db.Timestamptz(6)
  is_active      Boolean        @default(true)
  ai_decisions   ai_decisions[]

  @@map("ai_agents")
}

model ai_decisions {
  id                     Int                      @id @default(autoincrement())
  agent_id               Int
  contest_id             Int
  decision_type          AIDecisionType
  token_id               Int
  amount                 Decimal                  @db.Decimal(20, 0)
  reasoning              String                   @db.VarChar
  market_context         Json?                    @default("{}")
  external_factors       Json?                    @default("{}")
  timestamp              DateTime                 @default(now()) @db.Timestamptz(6)
  success_score          Int?
  price_impact           Decimal?                 @db.Decimal(20, 8)
  ai_agents              ai_agents                @relation(fields: [agent_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  contests               contests                 @relation(fields: [contest_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  tokens                 tokens                   @relation(fields: [token_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  participant_influences participant_influences[]

  @@index([contest_id, timestamp], map: "idx_ai_decisions_contest_time")
  @@index([token_id, timestamp], map: "idx_ai_decisions_token_time")
  @@map("ai_decisions")
}

model auth_challenges {
  wallet_address String    @id
  nonce          String
  expires_at     DateTime  @db.Timestamptz(6)
  created_at     DateTime? @default(now()) @db.Timestamptz(6)

  @@index([expires_at], map: "idx_auth_challenges_expires")
  @@map("auth_challenges")
}

model biometric_credentials {
  id            Int       @id @default(autoincrement())
  credential_id String    @unique
  public_key    String
  device_info   Json?     @default("{}")
  created_at    DateTime  @default(now()) @db.Timestamptz(6)
  last_used     DateTime? @db.Timestamptz(6)
  counter       BigInt    @default(0)
  user_id       Int
  user          users     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id], map: "idx_biometric_credentials_user")
  @@map("biometric_credentials")
}

model biometric_auth_challenges {
  id            String   @id @default(cuid())
  user_id       Int
  challenge     String   @unique
  type          String
  credential_id String?
  expires_at    DateTime @db.Timestamptz(6)
  created_at    DateTime @default(now()) @db.Timestamptz(6)
  user          users    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([expires_at])
  @@map("biometric_auth_challenges")
}

model blockchain_transactions {
  id           Int                @id @default(autoincrement())
  tx_hash      String             @unique @db.VarChar
  wallet_from  String             @db.VarChar
  wallet_to    String             @db.VarChar
  amount       Decimal            @db.Decimal(20, 8)
  token_type   TokenType          @default(SOL)
  chain        Chain              @default(SOLANA)
  status       transaction_status @default(pending)
  type         transaction_type
  contest_id   Int?
  created_at   DateTime           @default(now()) @db.Timestamptz(6)
  confirmed_at DateTime?          @db.Timestamptz(6)
  error        String?            @db.VarChar
  signature    String?            @db.VarChar
  slot         Int?
  contests     contests?          @relation(fields: [contest_id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([contest_id], map: "idx_blockchain_transactions_contest")
  @@index([signature], map: "idx_blockchain_transactions_signature")
  @@index([tx_hash], map: "idx_blockchain_transactions_hash")
  @@index([wallet_from, wallet_to], map: "idx_blockchain_transactions_wallets")
  @@map("blockchain_transactions")
}

model contest_wallets {
  id             Int       @id @default(autoincrement())
  contest_id     Int       @unique
  wallet_address String    @db.VarChar
  private_key    String    @db.VarChar
  balance        Decimal   @db.Decimal(20, 8)
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  updated_at     DateTime? @db.Timestamptz(6)
  last_sync      DateTime? @db.Timestamptz(6)
  is_vanity      Boolean   @default(false)
  vanity_type    String?   @db.VarChar
  contests       contests  @relation(fields: [contest_id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([wallet_address], map: "idx_contest_wallets_wallet")
  @@map("contest_wallets")
}

model seed_wallets {
  wallet_address String   @id
  private_key    String
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt
  is_active      Boolean  @default(true)
  purpose        String?
  metadata       Json?
}

model banned_ips {
  id           Int       @id @default(autoincrement())
  ip_address   String    @unique
  reason       String
  is_permanent Boolean   @default(false)
  expires_at   DateTime? @db.Timestamptz(6)
  created_at   DateTime  @default(now()) @db.Timestamptz(6)
  created_by   String    @db.VarChar(44)
  updated_at   DateTime? @updatedAt @db.Timestamptz(6)
  num_attempts Int       @default(0)
  troll_level  Int       @default(1)
  metadata     Json?     @default("{}")

  @@index([ip_address], map: "idx_banned_ips_address")
  @@index([expires_at], map: "idx_banned_ips_expires")
  @@map("banned_ips")
}

model user_ip_history {
  id             Int      @id @default(autoincrement())
  wallet_address String   @db.VarChar(44)
  ip_address     String   @db.VarChar(45)
  user_agent     String?
  first_seen     DateTime @default(now()) @db.Timestamptz(6)
  last_seen      DateTime @default(now()) @db.Timestamptz(6)
  access_count   Int      @default(1)
  country_code   String?  @db.VarChar(2)
  region         String?  @db.VarChar(100)
  city           String?  @db.VarChar(100)
  is_suspicious  Boolean  @default(false)
  notes          String?
  metadata       Json?    @default("{}")
  users          users    @relation(fields: [wallet_address], references: [wallet_address], onDelete: Cascade)

  @@unique([wallet_address, ip_address], name: "user_ip_unique")
  @@index([ip_address], map: "idx_user_ip_address")
  @@index([wallet_address], map: "idx_user_ip_wallet")
  @@index([is_suspicious], map: "idx_user_ip_suspicious")
  @@index([first_seen], map: "idx_user_ip_first_seen")
  @@index([last_seen], map: "idx_user_ip_last_seen")
  @@map("user_ip_history")
}

model participant_influences {
  id                  Int          @id @default(autoincrement())
  decision_id         Int
  wallet_address      String       @db.VarChar
  persuasion_score    Int
  contribution_weight Decimal      @db.Decimal(5, 2)
  timestamp           DateTime     @default(now()) @db.Timestamptz(6)
  ai_decisions        ai_decisions @relation(fields: [decision_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  users               users        @relation(fields: [wallet_address], references: [wallet_address], onDelete: NoAction, onUpdate: NoAction)

  @@index([wallet_address, decision_id], map: "idx_participant_influences_lookup")
  @@map("participant_influences")
}

model system_settings {
  key         String   @id @map("key")
  value       Json
  description String?
  updated_at  DateTime @default(now()) @db.Timestamptz(6)
  updated_by  String?  @db.VarChar(44)

  @@map("system_settings")
}

model system_notices {
  id         Int       @id @default(autoincrement())
  title      String?   @db.VarChar(255)
  message    String
  type       String    @default("info") @db.VarChar(50)
  is_active  Boolean   @default(true)
  start_date DateTime? @db.Timestamptz(6)
  end_date   DateTime? @db.Timestamptz(6)
  created_at DateTime  @default(now()) @db.Timestamptz(6)
  updated_at DateTime  @updatedAt @db.Timestamptz(6)

  @@index([is_active, start_date, end_date])
  @@map("system_notices")
}

model service_configuration {
  id                   String    @id @default(cuid())
  service_name         String    @unique
  display_name         String
  enabled              Boolean   @default(true)
  check_interval_ms    Int       @default(60000)
  circuit_breaker      Json?
  backoff              Json?
  thresholds           Json?
  last_updated         DateTime  @default(now()) @updatedAt
  updated_by           String?
  last_run_at          DateTime?
  last_run_duration_ms Int?
  last_status          String?
  status_message       String?

  @@map("service_configuration")
}

model achievement_categories {
  id          Int      @id @default(autoincrement())
  name        String   @unique @db.VarChar(50)
  description String?
  created_at  DateTime @default(now()) @db.Timestamptz(6)

  @@map("achievement_categories")
}

model achievement_tiers {
  id         Int      @id @default(autoincrement())
  name       String   @db.VarChar(20)
  color_hex  String   @db.VarChar(7)
  points     Int
  created_at DateTime @default(now()) @db.Timestamptz(6)

  @@map("achievement_tiers")
}

model user_levels {
  id                             Int      @id @default(autoincrement())
  level_number                   Int
  class_name                     String   @db.VarChar(20)
  title                          String   @db.VarChar(50)
  min_exp                        Int
  bronze_achievements_required   Int
  silver_achievements_required   Int
  gold_achievements_required     Int
  platinum_achievements_required Int
  diamond_achievements_required  Int
  icon_url                       String?
  created_at                     DateTime @default(now()) @db.Timestamptz(6)
  users                          users[]

  @@map("user_levels")
}

model achievement_tier_requirements {
  id                Int      @id @default(autoincrement())
  achievement_type  String
  tier_id           Int
  requirement_value Json
  created_at        DateTime @default(now()) @db.Timestamptz(6)

  @@index([achievement_type, tier_id], map: "idx_achievement_tier_requirements_lookup")
  @@map("achievement_tier_requirements")
}

model level_rewards {
  id           Int      @id @default(autoincrement())
  level_id     Int
  reward_type  String   @db.VarChar(50)
  reward_value Json
  created_at   DateTime @default(now()) @db.Timestamptz(6)

  @@map("level_rewards")
}

model websocket_messages {
  id             Int       @id @default(autoincrement())
  type           String
  data           Json
  wallet_address String
  timestamp      DateTime  @default(now()) @db.Timestamptz(6)
  delivered      Boolean   @default(false)
  delivered_at   DateTime? @db.Timestamptz(6)
  read           Boolean   @default(false)
  read_at        DateTime? @db.Timestamptz(6)
  users          users     @relation(fields: [wallet_address], references: [wallet_address], onDelete: NoAction, onUpdate: NoAction)

  @@index([wallet_address, type], map: "idx_websocket_messages_wallet_type")
  @@index([timestamp], map: "idx_websocket_messages_timestamp")
  @@index([delivered_at], map: "idx_websocket_messages_delivered_at")
  @@index([read, wallet_address], map: "idx_websocket_messages_read_wallet")
  @@map("websocket_messages")
}

model vanity_wallet_pool {
  id                  Int                @id @default(autoincrement())
  wallet_address      String?            @unique
  private_key         String?
  pattern             String
  is_used             Boolean            @default(false)
  used_at             DateTime?
  used_by_contest     Int?               @unique
  created_at          DateTime           @default(now())
  updated_at          DateTime           @updatedAt
  attempts            BigInt?
  callback_url        String?
  case_sensitive      Boolean            @default(true)
  completed_at        DateTime?
  duration_ms         BigInt?
  is_suffix           Boolean            @default(false)
  job_id              String?            @unique
  request_ip          String?
  requested_by        String?
  process_pid         Int?
  status              VanityWalletStatus @default(pending)
  attempts_per_second Float?
  contest             contests?          @relation(fields: [used_by_contest], references: [id])

  @@index([is_used])
  @@index([pattern])
  @@index([status])
  @@index([job_id])
  @@index([attempts_per_second])
}

model referrals {
  id              Int            @id @default(autoincrement())
  referrer_id     String         @db.VarChar(44)
  referred_id     String         @db.VarChar(44)
  referral_code   String         @db.VarChar(20)
  status          ReferralStatus @default(pending)
  source          String?
  landing_page    String?
  utm_source      String?
  utm_medium      String?
  utm_campaign    String?
  device          String?
  browser         String?
  ip_address      String?
  user_agent      String?
  session_id      String?
  click_timestamp DateTime?      @db.Timestamptz(6)
  reward_amount   Decimal?       @db.Decimal(20, 0)
  reward_paid_at  DateTime?      @db.Timestamptz(6)
  qualified_at    DateTime?      @db.Timestamptz(6)
  created_at      DateTime       @default(now()) @db.Timestamptz(6)
  referred        users          @relation("ReferredByRelation", fields: [referred_id], references: [wallet_address], onDelete: Cascade)
  referrer        users          @relation("ReferralsMadeRelation", fields: [referrer_id], references: [wallet_address], onDelete: Cascade)

  @@index([referrer_id])
  @@index([referred_id])
  @@index([referral_code])
  @@index([status])
}

model referral_clicks {
  id            Int       @id @default(autoincrement())
  referral_code String    @db.VarChar(20)
  referrer_id   String    @db.VarChar(44)
  source        String?
  landing_page  String?
  utm_source    String?
  utm_medium    String?
  utm_campaign  String?
  device        String?
  browser       String?
  ip_address    String
  user_agent    String?
  session_id    String
  converted     Boolean   @default(false)
  converted_at  DateTime? @db.Timestamptz(6)
  timestamp     DateTime  @default(now()) @db.Timestamptz(6)
  referrer      users     @relation("ReferralClicksReceived", fields: [referrer_id], references: [wallet_address], onDelete: Cascade)

  @@index([referral_code])
  @@index([referrer_id])
  @@index([session_id])
  @@index([ip_address])
}

model referral_rewards {
  id             Int                @id @default(autoincrement())
  wallet_address String             @db.VarChar(44)
  reward_type    ReferralRewardType
  amount         Decimal            @db.Decimal(20, 0)
  description    String?
  transaction_id Int?
  created_at     DateTime           @default(now()) @db.Timestamptz(6)
  paid_at        DateTime?          @db.Timestamptz(6)
  transaction    transactions?      @relation(fields: [transaction_id], references: [id])
  users          users              @relation(fields: [wallet_address], references: [wallet_address])

  @@index([wallet_address])
  @@index([created_at])
  @@map("referral_rewards")
}

model managed_wallets {
  id                    String   @id @default(uuid())
  public_key            String   @unique @db.VarChar(44)
  encrypted_private_key String
  label                 String?  @db.VarChar(255)
  status                String   @default("active") @db.VarChar(20)
  metadata              Json?    @default("{}")
  created_at            DateTime @default(now()) @db.Timestamptz(6)
  updated_at            DateTime @updatedAt @db.Timestamptz(6)
  ownerId               Int?
  memo                  String?
  owner                 users?   @relation("ManagedWalletOwner", fields: [ownerId], references: [id])
  ai_trade_executions   ai_trade_executions[]
  oauth_links           oauth_user_wallets[]

  @@index([ownerId])
  @@map("managed_wallets")
}

/// OAuth user ↔ wallet mapping for MCP HTTP sessions
model oauth_user_wallets {
  id             String   @id @default(uuid())
  provider       String   @db.VarChar(255)
  subject        String   @db.VarChar(255)
  email          String?  @db.VarChar(255)
  wallet_id      String
  default_wallet Boolean  @default(false)
  created_at     DateTime @default(now()) @db.Timestamptz(6)
  updated_at     DateTime @updatedAt @db.Timestamptz(6)

  wallet         managed_wallets @relation(fields: [wallet_id], references: [id], onDelete: Cascade)

  @@index([provider, subject])
  @@unique([provider, subject, wallet_id])
  @@map("oauth_user_wallets")
}

/// AI/Voice agent user table (separate from DegenDuel users)
model ai_app_users {
  id           String            @id @default(uuid())
  name         String?           @db.VarChar(255)
  role         String            @default("user") @db.VarChar(32)
  ext_user_id  Int?
  created_at   DateTime          @default(now()) @db.Timestamptz(6)

  // Relations
  tokens       ai_user_tokens[]
  settings     ai_user_settings?
  aliases      ai_wallet_aliases[]
  audits       ai_trade_audit[]
  // External mapping to DegenDuel users (optional); kept as scalar to avoid cross-relation requirement

  @@map("ai_app_users")
}

/// Mapping from dev/runtime token to ai_app_users
model ai_user_tokens {
  token       String      @id @db.VarChar(255)
  user_id     String
  created_at  DateTime    @default(now()) @db.Timestamptz(6)

  user        ai_app_users @relation(fields: [user_id], references: [id])

  @@map("ai_user_tokens")
}

/// Per-user default/last-used wallet settings for the AI agent
model ai_user_settings {
  user_id            String   @id
  default_wallet_id  String?
  last_used_wallet_id String?
  updated_at         DateTime @default(now()) @db.Timestamptz(6)

  user             ai_app_users     @relation(fields: [user_id], references: [id])

  @@index([user_id])
  @@map("ai_user_settings")
}

/// Friendly aliases per user for managed wallets (e.g., "trading", "treasury")
model ai_wallet_aliases {
  id         String   @id @default(uuid())
  user_id    String
  wallet_id  String
  alias      String   @db.VarChar(255)
  created_at DateTime @default(now()) @db.Timestamptz(6)

  user    ai_app_users    @relation(fields: [user_id], references: [id])

  @@unique([user_id, alias])
  @@index([user_id, alias])
  @@index([wallet_id])
  @@map("ai_wallet_aliases")
}

/// Append-only trade audit for AI-triggered actions
model ai_trade_audit {
  id          BigInt    @id @default(autoincrement())
  user_id     String?
  wallet_id   String?
  token_mint  String?   @db.VarChar(64)
  action      String    @db.VarChar(32)
  amount_ui   Decimal?  @db.Decimal(24, 9)
  tx_hash     String?   @db.VarChar(128)
  frames_json Json?
  created_at  DateTime  @default(now()) @db.Timestamptz(6)

  user    ai_app_users?    @relation(fields: [user_id], references: [id])

  @@index([user_id, created_at])
  @@index([wallet_id, created_at])
  @@map("ai_trade_audit")
}

model referral_periods {
  id         Int                        @id @default(autoincrement())
  start_date DateTime                   @db.Timestamptz(6)
  end_date   DateTime                   @db.Timestamptz(6)
  is_active  Boolean                    @default(true)
  status     String                     @default("in_progress")
  created_at DateTime                   @default(now()) @db.Timestamptz(6)
  updated_at DateTime                   @default(now()) @db.Timestamptz(6)
  rankings   referral_period_rankings[]
}

model referral_period_rankings {
  id             Int              @id @default(autoincrement())
  period_id      Int
  user_id        String           @db.VarChar(44)
  referral_count Int              @default(0)
  rank           Int
  trend          String           @default("stable")
  reward_amount  Decimal?         @db.Decimal(20, 0)
  status         String           @default("pending")
  created_at     DateTime         @default(now()) @db.Timestamptz(6)
  updated_at     DateTime         @default(now()) @db.Timestamptz(6)
  period         referral_periods @relation(fields: [period_id], references: [id], onDelete: Cascade)
  user           users            @relation(fields: [user_id], references: [wallet_address], onDelete: Cascade)

  @@unique([period_id, user_id])
  @@index([period_id])
  @@index([user_id])
}

model referral_milestones {
  id              Int      @id @default(autoincrement())
  user_id         String   @db.VarChar(44)
  milestone_level Int
  referral_count  Int
  reward_amount   Decimal  @db.Decimal(20, 0)
  status          String   @default("pending")
  created_at      DateTime @default(now()) @db.Timestamptz(6)
  updated_at      DateTime @default(now()) @db.Timestamptz(6)
  user            users    @relation(fields: [user_id], references: [wallet_address], onDelete: Cascade)

  @@unique([user_id, milestone_level])
  @@index([user_id])
}

model wallet_balance_history {
  id               Int      @id @default(autoincrement())
  wallet_address   String   @db.VarChar(44)
  balance_lamports BigInt
  timestamp        DateTime @default(now()) @db.Timestamptz(6)
  users            users    @relation(fields: [wallet_address], references: [wallet_address], onDelete: Cascade)

  @@index([wallet_address], map: "idx_wallet_balance_wallet")
  @@index([timestamp], map: "idx_wallet_balance_timestamp")
  @@map("wallet_balance_history")
}

model duel_token_balance_history {
  id               Int      @id @default(autoincrement())
  wallet_address   String   @db.VarChar(44)
  balance_lamports BigInt
  timestamp        DateTime @default(now()) @db.Timestamptz(6)
  users            users    @relation(fields: [wallet_address], references: [wallet_address], onDelete: Cascade)

  @@index([wallet_address], map: "idx_duel_balance_wallet")
  @@index([timestamp], map: "idx_duel_balance_timestamp")
  @@map("duel_token_balance_history")
}

model duel_token_daily_balance {
  id                               Int           @id @default(autoincrement())
  wallet_address                   String        @db.VarChar(44)
  date                             DateTime      @db.Date
  average_balance_lamports         BigInt
  total_registered_supply_lamports BigInt        @default(0)
  dividend_percentage              Decimal       @default(0.00) @db.Decimal(5, 2)
  daily_contest_revenue            Decimal       @default(0.00) @db.Decimal(10, 2)
  snapshot_count                   Int           @default(0)
  dividend_amount_sol              Decimal?      @db.Decimal(20, 8)
  dividend_transaction_id          Int?
  dividend_paid_at                 DateTime?     @db.Timestamptz(6)
  dividend_status                  String?       @default("pending") @db.VarChar(20)
  created_at                       DateTime      @default(now()) @db.Timestamptz(6)
  users                            users         @relation(fields: [wallet_address], references: [wallet_address], onDelete: Cascade)
  dividend_transaction             transactions? @relation(fields: [dividend_transaction_id], references: [id])

  @@unique([wallet_address, date], map: "idx_duel_daily_wallet_date")
  @@index([wallet_address], map: "idx_duel_daily_wallet")
  @@index([date], map: "idx_duel_daily_date")
  @@index([dividend_status], map: "idx_duel_daily_dividend_status")
  @@map("duel_token_daily_balance")
}

model circuit_breaker_states {
  id                Int                         @id @default(autoincrement())
  service_name      String                      @unique
  state             String                      @default("closed")
  failure_count     Int                         @default(0)
  last_failure      DateTime?
  recovery_attempts Int                         @default(0)
  updated_at        DateTime                    @updatedAt
  config            circuit_breaker_config?
  incidents         circuit_breaker_incidents[]

  @@index([state])
  @@map("circuit_breaker_states")
}

model circuit_breaker_incidents {
  id           String                 @id @default(uuid())
  service_name String
  type         String
  severity     String
  status       String                 @default("active")
  message      String
  start_time   DateTime               @default(now())
  end_time     DateTime?
  metrics      Json?
  state        circuit_breaker_states @relation(fields: [service_name], references: [service_name])

  @@index([service_name, status])
  @@index([start_time])
  @@map("circuit_breaker_incidents")
}

model circuit_breaker_config {
  service_name      String                 @id
  failure_threshold Int                    @default(5)
  recovery_timeout  Int                    @default(30000)
  request_limit     Int                    @default(100)
  monitoring_window Int                    @default(60000)
  minimum_requests  Int                    @default(10)
  updated_at        DateTime               @updatedAt
  state             circuit_breaker_states @relation(fields: [service_name], references: [service_name])

  @@map("circuit_breaker_config")
}

model authorized_devices {
  id             Int      @id @default(autoincrement())
  wallet_address String
  device_id      String
  device_name    String?
  device_type    String?
  last_used      DateTime @default(now()) @db.Timestamptz(6)
  created_at     DateTime @default(now()) @db.Timestamptz(6)
  is_active      Boolean  @default(true)
  user           users    @relation("UserAuthorizedDevices", fields: [wallet_address], references: [wallet_address], onDelete: Cascade)

  @@unique([wallet_address, device_id], name: "authorized_devices_wallet_address_device_id_key")
  @@index([wallet_address], map: "idx_authorized_devices_wallet")
  @@index([device_id], map: "idx_authorized_devices_device_id")
  @@map("authorized_devices")
}

model token_socials {
  id         Int       @id @default(autoincrement())
  token_id   Int
  type       String
  url        String
  created_at DateTime? @default(now())
  token      tokens    @relation(fields: [token_id], references: [id])

  @@index([token_id])
  @@map("token_socials")
}

model token_websites {
  id         Int       @id @default(autoincrement())
  token_id   Int
  label      String?
  url        String
  created_at DateTime? @default(now())
  token      tokens    @relation(fields: [token_id], references: [id])

  @@index([token_id])
  @@map("token_websites")
}

model ai_conversations {
  id                String                     @id @default(uuid())
  wallet_address    String                     @db.VarChar(44)
  conversation_id   String                     @unique
  context           String?                    @db.VarChar(50)
  message_count     Int                        @default(0)
  total_tokens_used Int                        @default(0)
  first_message_at  DateTime                   @default(now()) @db.Timestamptz(6)
  last_message_at   DateTime                   @default(now()) @db.Timestamptz(6)
  is_active         Boolean                    @default(true)
  metadata          Json?                      @default("{}")
  messages          ai_conversation_messages[]
  user              users                      @relation("UserAIConversations", fields: [wallet_address], references: [wallet_address], onDelete: Cascade)

  @@index([wallet_address])
  @@index([conversation_id])
  @@index([last_message_at])
  @@map("ai_conversations")
}

model ai_conversation_messages {
  id              String           @id @default(uuid())
  conversation_id String
  role            String           @db.VarChar(20)
  content         String
  tokens          Int?
  created_at      DateTime         @default(now()) @db.Timestamptz(6)
  conversation    ai_conversations @relation(fields: [conversation_id], references: [conversation_id], onDelete: Cascade)

  @@index([conversation_id])
  @@index([created_at])
  @@map("ai_conversation_messages")
}

model ai_error_analyses {
  id                    Int                  @id @default(autoincrement())
  summary               String
  analyzed_at           DateTime             @default(now()) @db.Timestamptz(6)
  error_count           Int
  time_window_minutes   Int
  severity_distribution Json?                @default("{}")
  browser_distribution  Json?                @default("{}")
  os_distribution       Json?                @default("{}")
  top_errors            Json?                @default("[]")
  created_by            String?              @db.VarChar(44)
  actionability_score   Int?
  assigned_to           String?              @db.VarChar(44)
  estimated_cost_usd    Float?
  estimated_impact      String?              @db.VarChar(50)
  issue_categories      Json?                @default("[]")
  model_used            String?              @db.VarChar(50)
  priority              Int?
  recommended_actions   Json?                @default("[]")
  related_services      Json?                @default("[]")
  resolution_status     String?              @db.VarChar(20)
  tokens_completion     Int?
  tokens_prompt         Int?
  tokens_used           Int?
  analyzed_errors       ai_analyzed_errors[]

  @@index([analyzed_at])
  @@index([resolution_status])
  @@index([assigned_to])
  @@map("ai_error_analyses")
}

model ai_analyzed_errors {
  id          Int               @id @default(autoincrement())
  error_id    String
  analysis_id Int
  analyzed_at DateTime          @default(now()) @db.Timestamptz(6)
  analysis    ai_error_analyses @relation(fields: [analysis_id], references: [id], onDelete: Cascade)

  @@unique([error_id, analysis_id])
  @@index([error_id])
  @@index([analysis_id])
  @@map("ai_analyzed_errors")
}

model ai_admin_action_analyses {
  id                  Int                         @id @default(autoincrement())
  summary             String
  analyzed_at         DateTime                    @default(now()) @db.Timestamptz(6)
  action_count        Int
  time_window_minutes Int
  action_distribution Json?                       @default("{}")
  admin_distribution  Json?                       @default("{}")
  top_actions         Json?                       @default("[]")
  created_by          String?                     @db.VarChar(44)
  analyzed_actions    ai_analyzed_admin_actions[]

  @@index([analyzed_at])
  @@map("ai_admin_action_analyses")
}

model ai_analyzed_admin_actions {
  id          Int                      @id @default(autoincrement())
  action_id   Int
  analysis_id Int
  analyzed_at DateTime                 @default(now()) @db.Timestamptz(6)
  analysis    ai_admin_action_analyses @relation(fields: [analysis_id], references: [id], onDelete: Cascade)

  @@unique([action_id, analysis_id])
  @@index([action_id])
  @@index([analysis_id])
  @@map("ai_analyzed_admin_actions")
}

model ai_log_analyses {
  id             Int      @id @default(autoincrement())
  summary        String
  analyzed_at    DateTime @default(now()) @db.Timestamptz(6)
  log_file       String   @db.VarChar(255)
  lines_analyzed Int
  created_by     String?  @db.VarChar(44)

  @@index([analyzed_at])
  @@map("ai_log_analyses")
}

model ai_service_log_analyses {
  id                     Int                        @id @default(autoincrement())
  service                String                     @db.VarChar(50)
  summary                String
  analyzed_at            DateTime                   @default(now()) @db.Timestamptz(6)
  log_count              Int
  time_window_hours      Int
  created_by             String?                    @db.VarChar(44)
  anomalies_detected     Json?                      @default("[]")
  common_operations      Json?                      @default("[]")
  health_status          String?                    @db.VarChar(20)
  log_patterns           Json?                      @default("[]")
  operation_frequency    Json?                      @default("{}")
  operation_success_rate Json?                      @default("{}")
  performance_metrics    Json?                      @default("{}")
  performance_score      Int?
  recommendations        Json?                      @default("[]")
  service_dependencies   Json?                      @default("[]")
  analyzed_logs          ai_analyzed_service_logs[]

  @@index([analyzed_at])
  @@index([service])
  @@index([health_status])
  @@map("ai_service_log_analyses")
}

model ai_analyzed_service_logs {
  id          Int                     @id @default(autoincrement())
  log_id      Int
  service     String                  @db.VarChar(50)
  analysis_id Int
  analyzed_at DateTime                @default(now()) @db.Timestamptz(6)
  analysis    ai_service_log_analyses @relation(fields: [analysis_id], references: [id], onDelete: Cascade)

  @@unique([log_id, analysis_id])
  @@index([log_id])
  @@index([analysis_id])
  @@index([service])
  @@map("ai_analyzed_service_logs")
}

model service_logs {
  id             Int      @id @default(autoincrement())
  service        String   @db.VarChar(50)
  level          String   @db.VarChar(20)
  message        String
  details        Json?    @default("{}")
  metadata       Json?    @default("{}")
  instance_id    String?  @db.VarChar(100)
  created_at     DateTime @default(now()) @db.Timestamptz(6)
  related_entity String?  @db.VarChar(100)
  event_type     String?  @db.VarChar(50)
  duration_ms    Int?
  environment    String?  @db.VarChar(20)

  @@index([service, level])
  @@index([created_at])
  @@index([service, created_at])
  @@index([level, created_at])
  @@index([related_entity])
  @@index([event_type])
  @@map("service_logs")
}

model websocket_connections {
  id                Int       @id @default(autoincrement())
  connection_id     String
  ip_address        String    @db.VarChar(45)
  user_agent        String?
  wallet_address    String?   @db.VarChar(44)
  nickname          String?   @db.VarChar(100)
  is_authenticated  Boolean   @default(false)
  environment       String?   @db.VarChar(20)
  origin            String?
  connected_at      DateTime  @default(now()) @db.Timestamptz(6)
  disconnected_at   DateTime? @db.Timestamptz(6)
  duration_seconds  Int?
  close_code        Int?
  close_reason      String?
  subscribed_topics Json?     @default("[]")
  messages_received Int       @default(0)
  messages_sent     Int       @default(0)
  connection_error  String?
  country           String?   @db.VarChar(2)
  region            String?   @db.VarChar(100)
  city              String?   @db.VarChar(100)
  metadata          Json?     @default("{}")

  @@index([connection_id])
  @@index([ip_address])
  @@index([wallet_address])
  @@index([connected_at])
  @@index([disconnected_at])
  @@index([is_authenticated])
  @@map("websocket_connections")
}

model client_errors {
  id               Int       @id @default(autoincrement())
  error_id         String    @unique
  wallet_address   String?   @db.VarChar(44)
  user_id          Int?
  message          String
  level            String    @default("error") @db.VarChar(20)
  stack_trace      String?
  source_url       String?
  line_number      Int?
  column_number    Int?
  browser          String?   @db.VarChar(100)
  browser_version  String?   @db.VarChar(50)
  os               String?   @db.VarChar(50)
  device           String?   @db.VarChar(50)
  ip_address       String?   @db.VarChar(45)
  session_id       String?   @db.VarChar(100)
  environment      String?   @db.VarChar(20)
  status           String?   @default("open") @db.VarChar(20)
  resolved_at      DateTime? @db.Timestamptz(6)
  resolved_by      String?   @db.VarChar(44)
  resolution_note  String?
  is_critical      Boolean?  @default(false)
  occurrences      Int       @default(1)
  last_occurred_at DateTime? @default(now()) @db.Timestamptz(6)
  created_at       DateTime  @default(now()) @db.Timestamptz(6)
  metadata         Json?     @default("{}")
  tags             String[]
  user             users?    @relation(fields: [user_id], references: [id])

  @@index([wallet_address], map: "idx_client_errors_wallet")
  @@index([status], map: "idx_client_errors_status")
  @@index([created_at], map: "idx_client_errors_created")
  @@index([last_occurred_at], map: "idx_client_errors_occurred")
  @@index([is_critical], map: "idx_client_errors_critical")
  @@index([session_id], map: "idx_client_errors_session")
  @@map("client_errors")
}

model config_solana_engine {
  id                      String   @id @default(cuid())
  token_metadata_ttl      Int      @default(86400)
  token_price_ttl         Int      @default(3600)
  wallet_data_ttl         Int      @default(300)
  connection_strategy     String   @default("adaptive")
  health_check_interval   Int      @default(60000)
  failure_threshold       Int      @default(2)
  recovery_threshold      Int      @default(3)
  max_concurrent_requests Int      @default(5)
  request_spacing_ms      Int      @default(100)
  base_backoff_ms         Int      @default(250)
  endpoint_weights        Json?    @default("{}")
  admin_bypass_cache      Boolean  @default(false)
  last_updated            DateTime @default(now()) @updatedAt
  updated_by              String?  @db.VarChar(44)

  @@map("config_solana_engine")
}

model config_contest_wallet {
  id                       String   @id @default(cuid())
  check_interval_ms        Int      @default(60000)
  min_balance_to_reclaim   Decimal  @default(0.05) @db.Decimal(10, 8)
  min_amount_to_transfer   Decimal  @default(0.01) @db.Decimal(10, 8)
  reclaim_contest_statuses Json     @default("[\"completed\", \"cancelled\"]")
  vanity_wallet_paths      Json     @default("{\"DUEL\": \"/home/websites/degenduel/addresses/keypairs/public/_DUEL\", \"DEGEN\": \"/home/websites/degenduel/addresses/keypairs/public/_DEGEN\"}")
  encryption_algorithm     String   @default("aes-256-gcm")
  failure_threshold        Int      @default(5)
  reset_timeout_ms         Int      @default(60000)
  min_healthy_period_ms    Int      @default(120000)
  initial_delay_ms         Int      @default(1000)
  max_delay_ms             Int      @default(30000)
  backoff_factor           Int      @default(2)
  enable_vanity_wallets    Boolean  @default(true)
  last_updated             DateTime @default(now()) @updatedAt
  updated_by               String?  @db.VarChar(44)

  @@map("config_contest_wallet")
}

model config_admin_wallet {
  id                       String   @id @default(cuid())
  check_interval_ms        Int      @default(60000)
  min_sol_balance          Decimal  @default(0.05) @db.Decimal(10, 8)
  max_parallel_transfers   Int      @default(5)
  transfer_timeout_ms      Int      @default(30000)
  max_batch_size           Int      @default(50)
  encryption_algorithm     String   @default("aes-256-gcm")
  key_length               Int      @default(32)
  iv_length                Int      @default(16)
  tag_length               Int      @default(16)
  failure_threshold        Int      @default(7)
  reset_timeout_ms         Int      @default(80000)
  min_healthy_period_ms    Int      @default(150000)
  initial_delay_ms         Int      @default(1000)
  max_delay_ms             Int      @default(30000)
  backoff_factor           Int      @default(2)
  require_admin_approval   Boolean  @default(true)
  large_transfer_threshold Decimal  @default(10.0) @db.Decimal(10, 8)
  last_updated             DateTime @default(now()) @updatedAt
  updated_by               String?  @db.VarChar(44)

  @@map("config_admin_wallet")
}

model config_ai_service {
  id                            String   @id @default(cuid())
  check_interval_ms             Int      @default(600000)
  client_error_lookback_minutes Int      @default(10)
  min_errors_to_analyze         Int      @default(1)
  admin_action_lookback_minutes Int      @default(15)
  min_actions_to_analyze        Int      @default(1)
  model_loadouts                Json     @default("{\"default\": {\"model\": \"gpt-4.1-mini\", \"maxTokens\": 4048, \"temperature\": 0.4}, \"adminAnalysis\": {\"model\": \"gpt-4.1-mini\", \"maxTokens\": 4048, \"temperature\": 0.4}, \"errorAnalysis\": {\"model\": \"gpt-4.1-mini\", \"maxTokens\": 4048, \"temperature\": 0.4}}")
  system_prompts                Json     @default("{}")
  failure_threshold             Int      @default(3)
  reset_timeout_ms              Int      @default(30000)
  max_tokens_per_minute         Int      @default(100000)
  max_conversations_per_user    Int      @default(5)
  enable_error_analysis         Boolean  @default(true)
  enable_admin_analysis         Boolean  @default(true)
  enable_user_ai_convos         Boolean  @default(true)
  last_updated                  DateTime @default(now()) @updatedAt
  updated_by                    String?  @db.VarChar(44)

  @@map("config_ai_service")
}

model rpc_benchmark_results {
  id             Int      @id @default(autoincrement())
  test_run_id    String
  timestamp      DateTime @default(now())
  provider       String
  method         String
  test_type      String
  min_latency    Float?
  max_latency    Float?
  avg_latency    Float?
  median_latency Float?
  stdev          Float?
  success_count  Int      @default(0)
  failure_count  Int      @default(0)
  raw_latencies  Json?
  notes          String?

  @@index([test_run_id])
  @@index([provider])
  @@index([method])
  @@index([timestamp])
  @@map("rpc_benchmark_results")
}

model token_rank_history {
  id          Int      @id @default(autoincrement())
  token_id    Int
  rank        Int
  timestamp   DateTime @default(now()) @db.Timestamptz(6)
  source      String?  @db.VarChar(50)
  snapshot_id String?  @db.VarChar(100)
  timeframe   String?  @db.VarChar(20)
  tokens      tokens   @relation(fields: [token_id], references: [id], onDelete: Cascade)

  @@index([token_id])
  @@index([timestamp(sort: Desc)])
  @@index([token_id, timestamp(sort: Desc)])
  @@index([rank])
  @@map("token_rank_history")
}

model token_volume_history {
  id          Int      @id @default(autoincrement())
  token_id    Int
  volume      Decimal  @db.Decimal(20, 0)
  volume_usd  Decimal? @db.Decimal(20, 2)
  change_24h  Decimal? @db.Decimal(5, 2)
  timestamp   DateTime @default(now()) @db.Timestamptz(6)
  source      String?  @db.VarChar(50)
  snapshot_id String?  @db.VarChar(100)
  tokens      tokens   @relation(fields: [token_id], references: [id], onDelete: Cascade)

  @@index([token_id])
  @@index([timestamp(sort: Desc)])
  @@index([token_id, timestamp(sort: Desc)])
  @@index([volume_usd(sort: Desc)])
  @@map("token_volume_history")
}

model token_liquidity_history {
  id          Int      @id @default(autoincrement())
  token_id    Int
  liquidity   Decimal  @db.Decimal(20, 0)
  change_24h  Decimal? @db.Decimal(5, 2)
  timestamp   DateTime @default(now()) @db.Timestamptz(6)
  source      String?  @db.VarChar(50)
  snapshot_id String?  @db.VarChar(100)
  tokens      tokens   @relation(fields: [token_id], references: [id], onDelete: Cascade)

  @@index([token_id])
  @@index([timestamp(sort: Desc)])
  @@index([token_id, timestamp(sort: Desc)])
  @@index([liquidity(sort: Desc)])
  @@map("token_liquidity_history")
}

model token_market_cap_history {
  id          Int      @id @default(autoincrement())
  token_id    Int
  market_cap  Decimal  @db.Decimal(20, 0)
  fdv         Decimal? @db.Decimal(20, 0)
  change_24h  Decimal? @db.Decimal(5, 2)
  timestamp   DateTime @default(now()) @db.Timestamptz(6)
  source      String?  @db.VarChar(50)
  snapshot_id String?  @db.VarChar(100)
  tokens      tokens   @relation(fields: [token_id], references: [id], onDelete: Cascade)

  @@index([token_id])
  @@index([timestamp(sort: Desc)])
  @@index([token_id, timestamp(sort: Desc)])
  @@index([market_cap(sort: Desc)])
  @@map("token_market_cap_history")
}

model token_pools {
  address       String
  tokenAddress  String
  dex           String
  programId     String
  dataSize      Int
  tokenOffset   Int
  createdAt     DateTime @default(now())
  lastUpdated   DateTime @updatedAt
  // 🚀 REVOLUTIONARY POOL PRICING DATA
  liquidity_usd Decimal? @db.Decimal(20, 2)
  volume_24h    Decimal? @db.Decimal(20, 2)
  pool_price    Decimal? @db.Decimal(20, 10)
  labels        String? // JSON string of pool labels/tags
  token         tokens   @relation(fields: [tokenAddress], references: [address], onDelete: Cascade)

  @@id([address, tokenAddress])
  @@index([dex])
  @@index([tokenAddress])
  @@index([liquidity_usd(sort: Desc)])
  @@index([volume_24h(sort: Desc)])
  @@map("token_pools")
}

model monitored_tokens {
  token_address         String   @id @db.VarChar(44)
  token_name            String?
  token_symbol          String?
  decimals              Int      @default(9)
  monitor_buys          Boolean  @default(true)
  monitor_sells         Boolean  @default(true)
  min_transaction_value Decimal  @default(0) @db.Decimal(20, 8)
  created_at            DateTime @default(now()) @db.Timestamptz(6)
  updated_at            DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  token                 tokens   @relation(fields: [token_address], references: [address], onDelete: Cascade)

  @@map("monitored_tokens")
}

model token_config {
  id                           Int     @id @default(autoincrement())
  symbol                       String  @db.VarChar(10)
  total_supply                 BigInt
  initial_circulating          BigInt
  community_allocation_percent Int
  team_allocation_percent      Int
  treasury_allocation_percent  Int
  initial_price                Decimal @db.Decimal(20, 10)
  launch_method                String  @db.VarChar(50)
  address                      String? @db.VarChar(44)

  @@map("token_config")
}

model contest_schedule {
  id                        Int               @id @default(autoincrement())
  name                      String
  template_id               Int
  hour                      Int?
  minute                    Int?              @default(0)
  days                      Int[]
  entry_fee_override        Decimal?          @db.Decimal(20, 8)
  name_override             String?
  description_override      String?
  duration_hours            Float?            @default(1.0)
  enabled                   Boolean           @default(true)
  advance_notice_hours      Int?              @default(1)
  min_participants_override Int?
  max_participants_override Int?
  allow_multiple_hours      Boolean           @default(false)
  multiple_hours            Int[]
  created_at                DateTime          @default(now()) @db.Timestamptz(6)
  updated_at                DateTime          @updatedAt @db.Timestamptz(6)
  template                  contest_templates @relation(fields: [template_id], references: [id])
  contests                  contests[]

  @@index([enabled])
  @@index([template_id])
  @@map("contest_schedule")
}

model roadmap_phases {
  id             Int             @id @default(autoincrement())
  quarter_number Int
  year           Int
  title          String          @db.VarChar(100)
  tasks          roadmap_tasks[]

  @@map("roadmap_phases")
}

model roadmap_tasks {
  id          Int            @id @default(autoincrement())
  phase_id    Int
  description String
  phase       roadmap_phases @relation(fields: [phase_id], references: [id])

  @@map("roadmap_tasks")
}

model platform_stats {
  id                Int     @id @default(autoincrement())
  user_count        Int     @default(0)
  upcoming_contests Int     @default(0)
  total_prize_pool  Decimal @default(0)
  waitlist_count    Int     @default(0)

  @@map("platform_stats")
}

model terminal_commands {
  id               Int    @id @default(autoincrement())
  command_name     String @unique @db.VarChar(50)
  command_response String

  @@map("terminal_commands")
}

model pool_price_changes {
  id            Int      @id @default(autoincrement())
  tokenAddress  String   @db.VarChar(44)
  poolAddress   String
  price         Decimal  @db.Decimal(20, 8)
  previousPrice Decimal  @db.Decimal(20, 8)
  changePercent Decimal  @db.Decimal(20, 8)
  liquidity     Decimal  @default(0) @db.Decimal(20, 0)
  timestamp     DateTime @default(now()) @db.Timestamptz(6)
  token         tokens   @relation(fields: [tokenAddress], references: [address], onDelete: Cascade)

  @@index([tokenAddress])
  @@index([poolAddress])
  @@index([timestamp(sort: Desc)])
  @@index([tokenAddress, timestamp(sort: Desc)])
  @@index([changePercent(sort: Desc)])
  @@map("pool_price_changes")
}

model token_refresh_priority_tiers {
  id                       Int      @id @default(autoincrement())
  name                     String   @unique @db.VarChar(50)
  description              String?
  priority_score           Int
  refresh_interval_seconds Int
  rank_threshold           Int
  volatility_factor        Float    @default(1.0)
  max_tokens_per_batch     Int?
  batch_delay_ms           Int?
  token_count              Int      @default(0)
  created_at               DateTime @default(now()) @db.Timestamptz(6)
  updated_at               DateTime @updatedAt @db.Timestamptz(6)
  updated_by               String?  @db.VarChar(44)
  is_active                Boolean  @default(true)

  @@index([priority_score])
  @@index([refresh_interval_seconds])
  @@index([rank_threshold])
  @@index([is_active])
  @@map("token_refresh_priority_tiers")
}

model contest_creation_credits {
  id                     Int        @id @default(autoincrement())
  user_id                String     @db.VarChar(44)
  source                 String     @db.VarChar(50)
  status                 String     @default("active") @db.VarChar(20)
  created_at             DateTime   @default(now()) @db.Timestamptz(6)
  used_at                DateTime?  @db.Timestamptz(6)
  expires_at             DateTime?  @db.Timestamptz(6)
  price_paid             Decimal?   @db.Decimal(20, 8)
  transaction_id         String?    @db.VarChar(64)
  granted_by             String?    @db.VarChar(44)
  metadata               Json?      @default("{}")
  purchase_txn_signature String?    @db.VarChar(100)
  receipt_number         String?    @db.VarChar(30)
  contest_settings       Json?      @default("{}")
  user                   users      @relation("UserContestCredits", fields: [user_id], references: [wallet_address], onDelete: Cascade)
  contest                contests[]

  @@index([user_id])
  @@index([status])
  @@index([expires_at])
  @@index([source])
  @@map("contest_creation_credits")
}

model pending_contest_entries {
  id             Int      @id @default(autoincrement())
  wallet_address String   @db.VarChar(44)
  contest_id     Int
  portfolio      Json
  status         String   @default("pending")
  created_at     DateTime @default(now()) @db.Timestamptz(6)
  updated_at     DateTime @updatedAt @db.Timestamptz(6)
  expires_at     DateTime @db.Timestamptz(6)
  contest        contests @relation("ContestPendingEntries", fields: [contest_id], references: [id], onDelete: Cascade)
  user           users    @relation("UserPendingContestEntries", fields: [wallet_address], references: [wallet_address], onDelete: Cascade)

  @@index([wallet_address])
  @@index([contest_id])
  @@index([status])
  @@index([expires_at])
}

model JupLike {
  id            Int           @id @default(autoincrement())
  username      String        @db.VarChar(30)
  status        JupLikeStatus @default(LIKING)
  updatedAt     DateTime      @updatedAt @map("updated_at") @db.Timestamptz(6)
  token_address String        @db.VarChar(44)

  @@unique([token_address, username])
  @@index([token_address])
  @@index([username])
  @@map("jup_likes")
}

model user_privileges {
  id             Int       @id @default(autoincrement())
  wallet_address String    @db.VarChar(44)
  privilege_key  String    @db.VarChar(100)
  source         String?   @db.VarChar(50)
  granted_at     DateTime  @default(now()) @db.Timestamptz(6)
  revoked_at     DateTime? @db.Timestamptz(6)
  metadata       Json?     @default("{}")
  user           users     @relation(fields: [wallet_address], references: [wallet_address], onDelete: Cascade)

  @@unique([wallet_address, privilege_key], name: "user_privilege_unique")
  @@index([wallet_address])
  @@index([privilege_key])
  @@index([revoked_at])
  @@map("user_privileges")
}

model BatchTransferItem {
  id                String   @id @default(cuid())
  batchIdentifier   String
  itemIdentifier    String   @unique
  status            String
  signature         String?
  error             String?
  fromWalletAddress String   @db.VarChar(44)
  toAddress         String   @db.VarChar(44)
  amount            Decimal  @db.Decimal(38, 18)
  mint              String?  @db.VarChar(44)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([batchIdentifier])
  @@index([fromWalletAddress])
  @@index([toAddress])
  @@index([status])
  @@map("batch_transfer_items")
}

model refresh_tokens {
  id             String    @id @default(cuid())
  token_hash     String    @unique
  user_id        Int
  wallet_address String
  expires_at     DateTime
  created_at     DateTime  @default(now())
  revoked_at     DateTime?
  user           users     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([wallet_address])
  @@index([expires_at])
  @@map("refresh_tokens")
}

model qr_auth_sessions {
  id            String    @id @default(cuid())
  session_token String    @unique
  session_data  Json?     @default("{}")
  status        String    @default("pending")
  expires_at    DateTime
  created_at    DateTime  @default(now())
  completed_at  DateTime?
  user_id       Int?
  user          users?    @relation("UserQrAuthSessions", fields: [user_id], references: [id])

  @@index([expires_at])
  @@index([status])
  @@map("qr_auth_sessions")
}

model tokens_to_monitor {
  id                     Int      @id @default(autoincrement())
  token_address          String   @unique @db.VarChar(44)
  token_name             String?  @db.VarChar(255)
  token_symbol           String?  @db.VarChar(20)
  is_active              Boolean  @default(true)
  discord_role_id        String?  @db.VarChar(20)
  role_name              String?  @db.VarChar(100)
  check_interval_seconds Int      @default(10)
  privilege_key          String   @db.VarChar(100)
  created_at             DateTime @default(now()) @db.Timestamptz(6)
  updated_at             DateTime @updatedAt @db.Timestamptz(6)

  @@index([is_active])
  @@index([token_address])
  @@map("tokens_to_monitor")
}

model dialect_auth_tokens {
  id             Int      @id @default(autoincrement())
  wallet_address String
  access_token   String
  refresh_token  String
  expires_at     DateTime
  created_at     DateTime @default(now())

  @@index([wallet_address])
  @@index([expires_at])
}

model dialect_blinks_usage {
  id                    Int      @id @default(autoincrement())
  blink_id              String
  wallet_address        String
  timestamp             DateTime @default(now())
  success               Boolean  @default(true)
  transaction_signature String?
  metadata              Json?

  @@index([blink_id])
  @@index([wallet_address])
  @@index([timestamp])
}

model telegram_users {
  id               Int                 @id @default(autoincrement())
  telegram_user_id String              @unique @db.VarChar(20)
  username         String?             @db.VarChar(32)
  first_name       String?             @db.VarChar(64)
  last_name        String?             @db.VarChar(64)
  is_bot           Boolean             @default(false)
  is_admin         Boolean             @default(false)
  is_linked        Boolean             @default(false)
  warning_count    Int                 @default(0)
  timeout_count    Int                 @default(0)
  ban_count        Int                 @default(0)
  first_seen       DateTime            @default(now()) @db.Timestamptz(6)
  last_seen        DateTime            @default(now()) @db.Timestamptz(6)
  last_message_at  DateTime            @default(now()) @db.Timestamptz(6)
  created_at       DateTime            @default(now()) @db.Timestamptz(6)
  updated_at       DateTime            @updatedAt @db.Timestamptz(6)
  messages         telegram_messages[]

  @@index([telegram_user_id])
  @@index([username])
  @@index([last_seen])
  @@index([is_admin])
  @@index([is_linked])
  @@map("telegram_users")
}

model telegram_messages {
  id                              Int            @id @default(autoincrement())
  message_id                      String         @db.VarChar(20)
  chat_id                         String         @db.VarChar(20)
  telegram_user_id                String         @db.VarChar(20)
  username                        String?        @db.VarChar(32)
  first_name                      String?        @db.VarChar(64)
  text                            String?
  message_type                    String         @default("text") @db.VarChar(20)
  caption                         String?
  forward_from_user_id            String?        @db.VarChar(20)
  forward_from_chat_id            String?        @db.VarChar(20)
  forward_from_chat_type          String?        @db.VarChar(20)
  forward_signature               String?        @db.VarChar(100)
  forward_date                    DateTime?      @db.Timestamptz(6)
  reply_to_message_id             String?        @db.VarChar(20)
  reply_to_text                   String?
  reply_to_user_id                String?        @db.VarChar(20)
  // NEW: External reply and quote support for latest Telegram Bot API
  external_reply_chat_id          String?        @db.VarChar(20)
  external_reply_origin_type      String?        @db.VarChar(20)
  external_reply_author_signature String?        @db.VarChar(100)
  quote_text                      String?
  quote_position                  Int?
  is_automatic_forward            Boolean        @default(false)
  has_protected_content           Boolean        @default(false)
  has_media                       Boolean        @default(false)
  media_type                      String?        @db.VarChar(20)
  is_edited                       Boolean        @default(false)
  event_type                      String?        @db.VarChar(20)
  raw_data                        Json?
  created_at                      DateTime       @default(now()) @db.Timestamptz(6)
  user                            telegram_users @relation(fields: [telegram_user_id], references: [telegram_user_id], onDelete: Cascade)

  @@unique([chat_id, message_id])
  @@index([chat_id, created_at(sort: Desc)])
  @@index([telegram_user_id])
  @@index([created_at(sort: Desc)])
  @@index([message_type])
  @@index([event_type])
  @@index([chat_id, telegram_user_id, created_at(sort: Desc)])
  // NEW: Indexes for spam detection based on external replies and quotes
  @@index([external_reply_chat_id])
  @@index([quote_text])
  @@map("telegram_messages")
}

/// Minimal persistence for TokenAI Telegram message fetches (non-conflicting with moderation tables)
model telegram_messages_tokenai {
  id             Int       @id @default(autoincrement())
  mint           String    @db.VarChar(44)
  chat_ref       String    @db.VarChar(255)
  message_id     String    @db.VarChar(40)
  date           DateTime? @db.Timestamptz(6)
  text           String?
  views          Int?
  forwards       Int?
  reply_to_msg_id String?  @db.VarChar(40)
  out            Boolean   @default(false)
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  updated_at     DateTime  @default(now()) @db.Timestamptz(6)

  @@unique([mint, chat_ref, message_id])
  @@index([mint, chat_ref, date(sort: Desc)])
  @@map("telegram_messages_tokenai")
}

model whale_status_history {
  id         Int      @id @default(autoincrement())
  user_id    Int
  balance    BigInt
  is_whale   Boolean
  tier       String?  @db.VarChar(20)
  checked_at DateTime @default(now()) @db.Timestamptz(6)
  user       users    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id], map: "idx_whale_history_user")
  @@index([checked_at(sort: Desc)], map: "idx_whale_history_checked")
  @@map("whale_status_history")
}

enum VanityWalletStatus {
  pending
  processing
  completed
  failed
  cancelled
}

enum UserRole {
  user
  admin
  superadmin
}

enum contest_status {
  pending
  active
  completed
  cancelled
}

enum contest_type {
  REGULAR
  PROMO
  CHALLENGE
}

enum challenge_status {
  PENDING_ACCEPTANCE
  ACCEPTED
  REJECTED
  EXPIRED
}

enum transaction_status {
  pending
  completed
  failed
  reversed
}

enum transaction_type {
  CONTEST_ENTRY
  PRIZE_PAYOUT
  DEPOSIT
  WITHDRAWAL
  REFERRAL_BONUS
  PROMOTION
  DIVIDEND
  AIRDROP
}

enum AIDecisionType {
  BUY
  SELL
  HOLD
  SPECIAL_EVENT
}

enum Chain {
  SOLANA
  ETHEREUM
  BSC
}

enum TokenType {
  SOL
  DUEL
  SPL
}

enum TradeType {
  BUY
  SELL
  SHORT
  CLOSE_SHORT
}

enum ReferralStatus {
  pending
  qualified
  rewarded
  expired
}

enum ReferralRewardType {
  signup_bonus
  contest_bonus
  special_event
}

enum JupLikeStatus {
  LIKING
  UNLIKED
}

// DIDI SUPERINTELLIGENT CONTEXT AWARENESS SYSTEM
// AI-maintained intelligence profiles and user tracking for enhanced context

model didi_user_intelligence_notes {
  id                  Int      @id @default(autoincrement())
  user_id             String   @unique @db.VarChar(20)
  personality_profile Json?    @default("{}")
  behavior_patterns   Json?    @default("[]")
  expertise           Json?    @default("{}")
  interests           Json?    @default("[]")
  relationships       Json?    @default("{}")
  quirks              Json?    @default("[]")
  ai_notes            String?
  message_count       Int      @default(0)
  created_at          DateTime @default(now()) @db.Timestamptz(6)
  updated_at          DateTime @updatedAt @db.Timestamptz(6)

  @@index([user_id])
  @@map("didi_user_intelligence_notes")
}

model didi_user_scores {
  id            Int      @id @default(autoincrement())
  user_id       String   @unique @db.VarChar(20)
  helpfulness   Decimal  @default(5.0) @db.Decimal(3, 2)
  engagement    Decimal  @default(5.0) @db.Decimal(3, 2)
  expertise     Decimal  @default(5.0) @db.Decimal(3, 2)
  sentiment     Decimal  @default(5.0) @db.Decimal(3, 2)
  influence     Decimal  @default(5.0) @db.Decimal(3, 2)
  consistency   Decimal  @default(5.0) @db.Decimal(3, 2)
  growth        Decimal  @default(5.0) @db.Decimal(3, 2)
  leadership    Decimal  @default(5.0) @db.Decimal(3, 2)
  overall_score Decimal  @default(5.0) @db.Decimal(3, 2)
  created_at    DateTime @default(now()) @db.Timestamptz(6)
  updated_at    DateTime @updatedAt @db.Timestamptz(6)

  @@index([user_id])
  @@index([overall_score])
  @@map("didi_user_scores")
}

model didi_conversation_summaries {
  id            Int      @id @default(autoincrement())
  chat_id       String   @db.VarChar(20)
  start_time    DateTime @db.Timestamptz(6)
  end_time      DateTime @db.Timestamptz(6)
  summary       String
  topics        Json?    @default("[]")
  participants  Json?    @default("{}")
  message_count Int      @default(0)
  created_at    DateTime @default(now()) @db.Timestamptz(6)

  @@index([chat_id])
  @@index([start_time, end_time])
  @@map("didi_conversation_summaries")
}

model didi_user_sentiment_history {
  id                   Int      @id @default(autoincrement())
  user_id              String   @db.VarChar(20)
  chat_id              String   @db.VarChar(20)
  sentiment_score      Decimal  @db.Decimal(3, 2)
  message_window_start DateTime @db.Timestamptz(6)
  message_window_end   DateTime @db.Timestamptz(6)
  message_count        Int      @default(0)
  created_at           DateTime @default(now()) @db.Timestamptz(6)

  @@index([user_id])
  @@index([message_window_start, message_window_end])
  @@map("didi_user_sentiment_history")
}

model didi_user_topic_interests {
  id              Int      @id @default(autoincrement())
  user_id         String   @db.VarChar(20)
  topic           String
  interest_score  Decimal  @default(0.0) @db.Decimal(3, 2)
  message_count   Int      @default(0)
  last_engagement DateTime @default(now()) @db.Timestamptz(6)
  created_at      DateTime @default(now()) @db.Timestamptz(6)
  updated_at      DateTime @updatedAt @db.Timestamptz(6)

  @@unique([user_id, topic])
  @@index([user_id])
  @@index([topic])
  @@map("didi_user_topic_interests")
}

model didi_user_behavior_changes {
  id             Int      @id @default(autoincrement())
  user_id        String   @db.VarChar(20)
  change_type    String
  description    String
  confidence     Decimal  @db.Decimal(3, 2)
  before_metrics Json?    @default("{}")
  after_metrics  Json?    @default("{}")
  detected_at    DateTime @default(now()) @db.Timestamptz(6)

  @@index([user_id])
  @@index([detected_at])
  @@map("didi_user_behavior_changes")
}

// 🔗 TELEGRAM ACCOUNT LINKING SYSTEM
model telegram_account_links {
  id               String    @id @default(cuid())
  telegram_user_id String    @unique
  wallet_address   String
  linked_at        DateTime  @default(now())
  last_used        DateTime?
  is_active        Boolean   @default(true)
  created_at       DateTime  @default(now())
  updated_at       DateTime  @updatedAt

  @@map("telegram_account_links")
}

model telegram_linking_tokens {
  id               String    @id @default(cuid())
  token            String    @unique
  telegram_user_id String
  expires_at       DateTime
  used_at          DateTime?
  is_used          Boolean   @default(false)
  created_at       DateTime  @default(now())

  @@map("telegram_linking_tokens")
}

model token_quality_levels {
  id             Int       @id @default(autoincrement())
  level_name     String    @unique @db.VarChar(50)
  min_liquidity  Int       @default(0)
  min_volume_24h Int       @default(0)
  min_market_cap Int       @default(0)
  require_image  Boolean   @default(false)
  max_age_days   Int       @default(30)
  is_active      Boolean   @default(true)
  description    String?
  created_at     DateTime? @default(now()) @db.Timestamptz(6)
  updated_at     DateTime? @default(now()) @db.Timestamptz(6)
  updated_by     String?   @db.VarChar(255)

  @@index([is_active], map: "idx_token_quality_levels_active")
  @@map("token_quality_levels")
}

// 🏦 WALLET PROFITABILITY TRACKING SYSTEM
model wallet_profitability_snapshots {
  id                      Int      @id @default(autoincrement())
  wallet_address          String   @db.VarChar(44)
  calculated_at           DateTime @default(now()) @db.Timestamptz(6)
  total_pnl_usd           Decimal  @default(0) @db.Decimal(20, 8)
  realized_pnl_usd        Decimal  @default(0) @db.Decimal(20, 8)
  unrealized_pnl_usd      Decimal  @default(0) @db.Decimal(20, 8)
  total_volume_usd        Decimal  @default(0) @db.Decimal(20, 8)
  trade_count             Int      @default(0)
  win_rate                Decimal  @default(0) @db.Decimal(5, 4)
  avg_trade_size_usd      Decimal  @default(0) @db.Decimal(20, 8)
  best_trade_pnl_usd      Decimal? @db.Decimal(20, 8)
  worst_trade_pnl_usd     Decimal? @db.Decimal(20, 8)
  portfolio_value_usd     Decimal  @default(0) @db.Decimal(20, 8)
  token_count             Int      @default(0)
  calculation_period_days Int      @default(365)
  created_at              DateTime @default(now()) @db.Timestamptz(6)

  positions wallet_token_positions[]

  @@index([wallet_address])
  @@index([calculated_at])
  @@index([total_pnl_usd])
  @@map("wallet_profitability_snapshots")
}

model wallet_token_positions {
  id                 Int      @id @default(autoincrement())
  snapshot_id        Int
  token_address      String   @db.VarChar(44)
  amount             Decimal  @db.Decimal(36, 18)
  value_usd          Decimal  @default(0) @db.Decimal(20, 8)
  cost_basis_usd     Decimal  @default(0) @db.Decimal(20, 8)
  unrealized_pnl_usd Decimal  @default(0) @db.Decimal(20, 8)
  avg_cost_per_token Decimal  @default(0) @db.Decimal(20, 8)
  current_price_usd  Decimal  @default(0) @db.Decimal(20, 8)
  return_percent     Decimal  @default(0) @db.Decimal(8, 4)
  created_at         DateTime @default(now()) @db.Timestamptz(6)

  snapshot wallet_profitability_snapshots @relation(fields: [snapshot_id], references: [id], onDelete: Cascade)

  @@index([snapshot_id])
  @@index([token_address])
  @@map("wallet_token_positions")
}

model wallet_trades_history {
  id                   Int      @id @default(autoincrement())
  wallet_address       String   @db.VarChar(44)
  transaction_hash     String   @db.VarChar(128)
  timestamp            DateTime @db.Timestamptz(6)
  trade_type           String   @db.VarChar(20) // 'swap', 'buy', 'sell'
  input_token_address  String   @db.VarChar(44)
  output_token_address String   @db.VarChar(44)
  input_amount         Decimal  @db.Decimal(36, 18)
  output_amount        Decimal  @db.Decimal(36, 18)
  input_value_usd      Decimal  @default(0) @db.Decimal(20, 8)
  output_value_usd     Decimal  @default(0) @db.Decimal(20, 8)
  pnl_usd              Decimal  @default(0) @db.Decimal(20, 8)
  platform             String   @db.VarChar(50)
  activity_type        String   @db.VarChar(50)
  created_at           DateTime @default(now()) @db.Timestamptz(6)

  @@unique([transaction_hash])
  @@index([wallet_address])
  @@index([timestamp])
  @@index([trade_type])
  @@index([pnl_usd])
  @@map("wallet_trades_history")
}

// LINE SKIN SYSTEM
model line_skins {
  id          Int          @id @default(autoincrement())
  name        String       @unique @db.VarChar(100)
  description String?      @db.Text
  tier        LineSkinTier
  design      Json // Stores the actual design configuration
  is_active   Boolean      @default(true)
  is_approved Boolean      @default(true)
  created_at  DateTime     @default(now()) @db.Timestamptz(6)
  updated_at  DateTime     @updatedAt @db.Timestamptz(6)

  user_line_skins user_line_skins[]

  @@index([tier])
  @@index([is_active])
  @@map("line_skins")
}

model user_line_skins {
  id             Int      @id @default(autoincrement())
  wallet_address String   @db.VarChar(44)
  skin_id        Int
  acquired_at    DateTime @default(now()) @db.Timestamptz(6)
  is_equipped    Boolean  @default(false)

  user users      @relation(fields: [wallet_address], references: [wallet_address])
  skin line_skins @relation(fields: [skin_id], references: [id])

  @@unique([wallet_address, skin_id])
  @@index([wallet_address])
  @@index([is_equipped])
  @@map("user_line_skins")
}

model airdrops {
  id               Int            @id @default(autoincrement())
  user_wallet      String         @db.VarChar(44)
  recipient_wallet String         @db.VarChar(44)
  amount           Decimal        @db.Decimal(20, 8)
  old_amount       Decimal?       @db.Decimal(20, 8)
  old_duel_sent    Decimal?       @default(0) @db.Decimal(20, 8)
  user_id          Int?
  token_address    String?        @db.VarChar(44)
  token_decimals   Int?           @default(6)
  status           airdrop_status @default(pending)
  transaction_id   Int?
  transaction_hash String?        @db.VarChar(128)
  error_message    String?        @db.Text
  created_at       DateTime       @default(now()) @db.Timestamptz(6)
  distributed_at   DateTime?      @db.Timestamptz(6)

  user        users?        @relation(fields: [user_id], references: [id])
  transaction transactions? @relation(fields: [transaction_id], references: [id])

  @@index([user_wallet])
  @@index([recipient_wallet])
  @@index([status])
  @@index([user_id])
  @@map("airdrops")
}

enum airdrop_status {
  pending
  processing
  completed
  failed
  cancelled
}

enum LineSkinTier {
  BASIC
  RARE
  SPECIAL
  ADMIN
  SUPERADMIN
}

model token_holder_snapshots {
  id                Int      @id @default(autoincrement())
  token_address     String   @db.VarChar(44)
  token_symbol      String   @db.VarChar(20)
  owner_address     String   @db.VarChar(44)
  token_account     String?  @db.VarChar(44)
  amount            Decimal  @db.Decimal(40, 0)
  decimals          Int      @default(9)
  ui_amount         Decimal  @db.Decimal(20, 9)
  rank              Int?
  timestamp         DateTime @default(now()) @db.Timestamptz(6)
  user_id           Int?
  snapshot_batch_id String   @db.Uuid
  created_at        DateTime @default(now()) @db.Timestamptz(6)

  // Change tracking fields
  previous_amount Decimal? @db.Decimal(40, 0)
  amount_change   Decimal? @db.Decimal(40, 0)
  is_new_holder   Boolean  @default(false)
  previous_rank   Int?

  // Wallet classification
  wallet_type       String? @db.VarChar(30)
  wallet_label      String? @db.VarChar(100)
  is_liquidity_pool Boolean @default(false)
  dex_program       String? @db.VarChar(50)

  user users? @relation(fields: [user_id], references: [id])

  @@index([token_address])
  @@index([owner_address])
  @@index([user_id])
  @@index([timestamp])
  @@index([snapshot_batch_id])
  @@index([is_new_holder])
  @@map("token_holder_snapshots")
}

model token_holder_snapshot_summary {
  id                     Int      @id @default(autoincrement())
  snapshot_batch_id      String   @unique @db.Uuid
  token_address          String   @db.VarChar(44)
  token_symbol           String   @db.VarChar(20)
  total_holders          Int
  registered_holders     Int
  total_supply_held      Decimal  @db.Decimal(40, 0)
  registered_supply_held Decimal  @db.Decimal(40, 0)
  timestamp              DateTime @default(now()) @db.Timestamptz(6)
  source                 String   @default("solscan") @db.VarChar(20)
  created_at             DateTime @default(now()) @db.Timestamptz(6)

  // Distribution metrics
  median_holdings         Decimal? @db.Decimal(20, 9)
  top_10_percentage       Decimal? @db.Decimal(5, 2)
  top_20_percentage       Decimal? @db.Decimal(5, 2)
  top_50_percentage       Decimal? @db.Decimal(5, 2)
  top_10_total_percentage Decimal? @db.Decimal(5, 2)
  top_20_total_percentage Decimal? @db.Decimal(5, 2)
  top_50_total_percentage Decimal? @db.Decimal(5, 2)

  // Movement tracking
  new_holders_count    Int     @default(0)
  exited_holders_count Int     @default(0)
  previous_snapshot_id String? @db.Uuid

  // Liquidity pool metrics
  liquidity_pool_amount             Decimal? @db.Decimal(40, 0)
  liquidity_pool_percentage         Decimal? @db.Decimal(5, 2)
  circulating_supply                Decimal? @db.Decimal(40, 0)
  registered_circulating_percentage Decimal? @db.Decimal(5, 2)

  @@index([token_address])
  @@index([snapshot_batch_id])
  @@index([previous_snapshot_id])
  @@map("token_holder_snapshot_summary")
}

model token_creation_vouchers {
  id                         Int      @id @default(autoincrement())
  user_id                    Int
  contest_id                 Int
  claimed                    Boolean  @default(false)
  expires_at                 DateTime @db.Timestamptz(6)
  contest_wallet_private_key String? // Encrypted

  // Token details (filled when claimed)
  token_mint        String? @db.VarChar(44)
  token_name        String? @db.VarChar(100)
  token_symbol      String? @db.VarChar(20)
  token_description String? @db.Text
  image_url         String? @db.VarChar(500)
  website           String? @db.VarChar(500)
  twitter           String? @db.VarChar(500)
  telegram          String? @db.VarChar(500)

  // Jupiter pool data
  pool_address       String?  @db.VarChar(44)
  config_key         String?  @db.VarChar(44)
  initial_market_cap Decimal? @default(90) @db.Decimal(10, 2)
  migration_cap      Decimal? @default(400) @db.Decimal(10, 2)

  // Platform settings (hardcoded for now)
  anti_sniping Boolean @default(false)
  lp_locked    Boolean @default(true)
  quote_token  String  @default("SOL") @db.VarChar(10)

  // Purchase tracking
  purchase_amount_sol   Decimal? @db.Decimal(10, 8)
  purchase_tx_signature String?  @db.VarChar(88)

  // Timestamps
  created_at DateTime  @default(now()) @db.Timestamptz(6)
  claimed_at DateTime? @db.Timestamptz(6)

  // Relations
  user            users                  @relation(fields: [user_id], references: [id])
  contest         contests               @relation(fields: [contest_id], references: [id])
  launched_tokens user_launched_tokens[]

  @@unique([user_id, contest_id]) // One voucher per user per contest
  @@index([user_id, claimed])
  @@index([expires_at])
  @@index([claimed])
  @@map("token_creation_vouchers")
}

model user_launched_tokens {
  id                  Int      @id @default(autoincrement())
  user_id             Int
  voucher_id          Int      @unique
  mint_address        String   @db.VarChar(44)
  wallet_private_key  String // Now belongs to user (encrypted)
  launch_timestamp    DateTime @default(now()) @db.Timestamptz(6)
  initial_purchase_tx String?  @db.VarChar(88)

  // Relations
  user    users                   @relation(fields: [user_id], references: [id])
  voucher token_creation_vouchers @relation(fields: [voucher_id], references: [id])

  @@index([user_id])
  @@index([mint_address])
  @@map("user_launched_tokens")
}

model pulse_buyer_cycles {
  id                  String    @id // cycle ID
  wallet_address      String    @db.VarChar(44)
  token_mint          String    @db.VarChar(44)
  state               String // "buying", "selling", "closing"
  start_time          DateTime  @default(now()) @db.Timestamptz(6)
  buy_amount          String? // BigInt as string
  buy_tx_signature    String?   @db.VarChar(88)
  sells_remaining     Int       @default(2)
  sell_1_scheduled_at DateTime? @db.Timestamptz(6)
  sell_1_tx_signature String?   @db.VarChar(88)
  sell_2_scheduled_at DateTime? @db.Timestamptz(6)
  sell_2_tx_signature String?   @db.VarChar(88)
  completed_at        DateTime? @db.Timestamptz(6)

  @@index([wallet_address])
  @@index([state])
  @@index([start_time])
  @@map("pulse_buyer_cycles")
}

// Twitter profile snapshots (exists in DB via prior migration; adding model back to prevent drops)
model twitter_snapshots {
  id                Int      @id @default(autoincrement())
  token_address     String   @db.VarChar(44)
  snapshot_time     DateTime @default(now()) @db.Timestamptz(6)
  follower_count    Int?
  following_count   Int?
  tweet_count       Int?
  is_verified       Boolean?
  profile_image_url String?
  header_image_url  String?
  bio               String?
  location          String?
  website           String?
  join_date         String?
  display_name      String?  @db.VarChar(200)
  handle            String?  @db.VarChar(100)

  // Note: Omitting Prisma relation field to avoid back-relation requirement; using scalar FK only

  @@index([token_address, snapshot_time], map: "twitter_snapshots_token_address_snapshot_time_idx")
  @@index([snapshot_time], map: "twitter_snapshots_snapshot_time_idx")
  @@map("twitter_snapshots")
}

// Twitter/X community snapshots (exists in DB via prior migration; adding model back to prevent drops)
model twitter_community_snapshots {
  id             Int      @id @default(autoincrement())
  token_address  String   @db.VarChar(44)
  community_url  String
  community_name String?
  snapshot_time  DateTime @default(now()) @db.Timestamptz(6)
  member_count   Int?
  description    String?
  is_private     Boolean  @default(false)
  rules          Json?

  // Note: Omitting Prisma relation field to avoid back-relation requirement; using scalar FK only

  @@index([token_address, snapshot_time], map: "twitter_community_snapshots_token_address_snapshot_time_idx")
  @@index([community_url], map: "twitter_community_snapshots_community_url_idx")
  @@map("twitter_community_snapshots")
}

// Tweets we track (exists in DB via prior migration; adding model back to prevent drops)
model twitter_tweets {
  tweet_id           String    @id @db.VarChar(32)
  token_address      String    @db.VarChar(44)
  author_handle      String    @db.VarChar(50)
  author_name        String?
  author_verified    Boolean   @default(false)
  tweet_text         String?
  tweet_timestamp    DateTime
  tweet_url          String?
  first_seen_at      DateTime  @default(now()) @db.Timestamptz(6)
  last_seen_at       DateTime  @default(now()) @db.Timestamptz(6)
  deleted_at         DateTime? @db.Timestamptz(6)
  likes_count        Int?      @default(0)
  retweets_count     Int?      @default(0)
  replies_count      Int?      @default(0)
  views_count        BigInt?
  is_reply           Boolean   @default(false)
  reply_to_handle    String?   @db.VarChar(50)
  replied_tweet_id   String?   @db.VarChar(32)
  replied_tweet_data Json?
  is_retweet         Boolean   @default(false)
  retweet_of_handle  String?   @db.VarChar(50)
  is_quote_tweet     Boolean   @default(false)
  quoted_tweet_id    String?   @db.VarChar(32)
  quoted_tweet_data  Json?
  is_thread          Boolean   @default(false)
  has_media          Boolean   @default(false)
  media_urls         Json?
  hashtags           Json?
  mentions           Json?
  external_links     Json?

  // Note: Omitting Prisma relation field to avoid back-relation requirement; using scalar FK only

  @@index([token_address, tweet_timestamp], map: "twitter_tweets_token_address_tweet_timestamp_idx")
  @@index([author_handle], map: "twitter_tweets_author_handle_idx")
  @@index([deleted_at], map: "twitter_tweets_deleted_at_idx")
  @@index([first_seen_at], map: "twitter_tweets_first_seen_at_idx")
  @@map("twitter_tweets")
}

// Tracks tweet price prediction verification scores
model tweet_prediction_scores {
  id                Int      @id @default(autoincrement())
  tweet_id          String   @db.VarChar(32)
  token_address     String   @db.VarChar(44)
  author_handle     String   @db.VarChar(50)
  tweet_timestamp   DateTime
  prediction_type   String   @db.VarChar(20) // pump, dump, target_price
  prediction_text   String?  @db.Text // The actual prediction extracted
  target_price      Float?   // For price targets
  minutes_checked   Int      // How many minutes after tweet we checked
  price_before      Float    // Price at tweet time
  price_after       Float    // Price at check time
  price_change_pct  Float    // Percentage change
  volume_before     Float?   // Volume at tweet time
  volume_after      Float?   // Volume at check time
  accuracy_score    Float    // 0-100 accuracy rating
  verdict           String   @db.Text // Human-readable verdict
  metadata          Json?    // Additional context/stats
  created_at        DateTime @default(now()) @db.Timestamptz(6)
  
  @@index([tweet_id])
  @@index([token_address, created_at])
  @@index([author_handle, accuracy_score])
  @@map("tweet_prediction_scores")
}

// Tracks members of Twitter/X Communities. One row per (community_url, user_handle).
model twitter_community_members {
  token_address String   @db.VarChar(44)
  community_url String
  user_handle   String   @db.VarChar(50)
  display_name  String?
  avatar_url    String?
  role          String   @default("member") @db.VarChar(20)
  first_seen_at DateTime @default(now()) @db.Timestamptz(6)
  last_seen_at  DateTime @default(now()) @db.Timestamptz(6)

  @@id([community_url, user_handle])
  @@index([token_address])
  @@index([community_url])
  @@index([role])
  @@map("twitter_community_members")
}

// API Keys for persistent bearer tokens
model api_keys {
  id             Int       @id @default(autoincrement())
  key_hash       String    @unique
  name           String
  wallet_address String    @db.VarChar(44)
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  last_used_at   DateTime? @db.Timestamptz(6)
  expires_at     DateTime? @db.Timestamptz(6)
  is_active      Boolean   @default(true)
  description    String?

  user users @relation(fields: [wallet_address], references: [wallet_address])

  @@index([key_hash])
  @@index([wallet_address])
  @@index([is_active])
  @@map("api_keys")
}

// AI Trading Decision tracking
model ai_trade_decisions {
  id                    String    @id @default(uuid())
  token_address         String    @db.VarChar(44)
  decision_type         String    @db.VarChar(20) // 'buy', 'sell', 'hold', 'exit'
  action                String    @db.VarChar(20) // 'market_buy', 'limit_buy', 'market_sell', 'stop_loss', 'take_profit'
  confidence_score      Decimal   @db.Decimal(5, 4) // 0.0000 to 1.0000
  confidence_components Json?     @default("{}") // {technical: 0.4, social: 0.3, fundamental: 0.2, risk_adjusted: 0.1}
  
  // Trade parameters
  amount_sol            Decimal?  @db.Decimal(20, 9) // Amount in SOL to trade
  price_target          Decimal?  @db.Decimal(20, 9) // Target price for limit orders
  slippage_tolerance    Decimal   @default(0.02) @db.Decimal(5, 4) // Max slippage (2% default)
  
  // Analysis context
  analysis_data         Json?     @default("{}") // Full analysis that led to decision
  indicators            Json?     @default("{}") // Technical indicators at decision time
  market_conditions     Json?     @default("{}") // Market state snapshot
  
  // Execution tracking
  executed              Boolean   @default(false)
  execution_id          String?   // Links to ai_trade_executions.id
  cancelled             Boolean   @default(false)
  cancel_reason         String?   @db.Text
  
  // Timestamps
  created_at            DateTime  @default(now()) @db.Timestamptz(6)
  executed_at           DateTime? @db.Timestamptz(6)
  expires_at            DateTime? @db.Timestamptz(6) // For time-bound orders
  
  // Relations
  execution             ai_trade_executions?
  
  @@index([token_address, created_at])
  @@index([executed, created_at])
  @@map("ai_trade_decisions")
}

// AI Trade Executions tracking
model ai_trade_executions {
  id                    String    @id @default(uuid())
  decision_id           String    @unique
  wallet_id             String    // References managed_wallets.id
  token_address         String    @db.VarChar(44)
  
  // Transaction details
  signature             String    @db.VarChar(88) // Solana transaction signature
  transaction_type      String    @db.VarChar(20) // 'buy', 'sell'
  
  // Amounts
  amount_in             Decimal   @db.Decimal(20, 9) // Amount sent
  amount_out            Decimal   @db.Decimal(20, 9) // Amount received
  token_in              String    @db.VarChar(44) // Token sent (address)
  token_out             String    @db.VarChar(44) // Token received (address)
  
  // Prices
  execution_price       Decimal   @db.Decimal(20, 9) // Actual execution price
  slippage              Decimal?  @db.Decimal(5, 4) // Actual slippage percentage
  
  // Fees
  gas_fee               Decimal?  @db.Decimal(20, 9) // Network fee in SOL
  platform_fee          Decimal?  @db.Decimal(20, 9) // Jupiter/DEX fee
  
  // Position tracking
  position_size_before  Decimal?  @db.Decimal(20, 9) // Token balance before trade
  position_size_after   Decimal?  @db.Decimal(20, 9) // Token balance after trade
  
  // Status
  status                String    @default("pending") @db.VarChar(20) // 'pending', 'confirmed', 'failed'
  error_message         String?   @db.Text
  
  // Timestamps
  created_at            DateTime  @default(now()) @db.Timestamptz(6)
  confirmed_at          DateTime? @db.Timestamptz(6)
  
  // Relations
  decision              ai_trade_decisions @relation(fields: [decision_id], references: [id], onDelete: Cascade)
  wallet                managed_wallets    @relation(fields: [wallet_id], references: [id])
  entry_positions       ai_trade_performance[] @relation("EntryExecution")
  exit_positions        ai_trade_performance[] @relation("ExitExecution")
  
  @@index([wallet_id, created_at])
  @@index([status, created_at])
  @@map("ai_trade_executions")
}

// AI Trade Performance tracking
model ai_trade_performance {
  id                    String    @id @default(uuid())
  token_address         String    @db.VarChar(44)
  
  // Position details
  entry_execution_id    String    
  exit_execution_id     String?   
  
  // Entry metrics
  entry_price           Decimal   @db.Decimal(20, 9)
  entry_amount_sol      Decimal   @db.Decimal(20, 9)
  entry_timestamp       DateTime  @db.Timestamptz(6)
  
  // Exit metrics (NULL if position still open)
  exit_price            Decimal?  @db.Decimal(20, 9)
  exit_amount_sol       Decimal?  @db.Decimal(20, 9)
  exit_timestamp        DateTime? @db.Timestamptz(6)
  exit_reason           String?   @db.VarChar(50) // 'take_profit', 'stop_loss', 'sentiment_flip', 'time_stop', 'manual'
  
  // Performance metrics
  pnl_sol               Decimal?  @db.Decimal(20, 9) // Profit/Loss in SOL
  pnl_percentage        Decimal?  @db.Decimal(10, 4) // Profit/Loss percentage
  holding_period_minutes Int?     // How long position was held
  max_drawdown          Decimal?  @db.Decimal(10, 4) // Maximum drawdown during hold
  max_profit            Decimal?  @db.Decimal(10, 4) // Maximum profit during hold
  
  // Analysis scores at entry/exit
  entry_confidence      Decimal   @db.Decimal(5, 4)
  entry_analysis        Json?     @default("{}")
  exit_analysis         Json?     @default("{}")
  
  // Learning metadata
  strategy_version      String?   @db.VarChar(20) // Which strategy version was used
  market_regime         String?   @db.VarChar(20) // 'bull', 'bear', 'crab', 'volatile'
  lessons_learned       Json?     @default("{}") // Patterns identified for learning
  
  // Status
  is_winner             Boolean?  // True if profitable, False if loss, NULL if open
  status                String    @default("open") @db.VarChar(20) // 'open', 'closed'
  
  // Timestamps
  created_at            DateTime  @default(now()) @db.Timestamptz(6)
  updated_at            DateTime  @updatedAt @db.Timestamptz(6)
  
  // Relations
  entry_execution       ai_trade_executions @relation("EntryExecution", fields: [entry_execution_id], references: [id])
  exit_execution        ai_trade_executions? @relation("ExitExecution", fields: [exit_execution_id], references: [id])
  
  @@index([token_address, created_at])
  @@index([status, created_at])
  @@map("ai_trade_performance")
}

// AI Strategy Parameters for autonomous trading
model ai_strategy_parameters {
  id                      String    @id @default(uuid())
  version                 String    @unique @db.VarChar(20) // 'v1.0', 'v1.1', etc.
  is_active               Boolean   @default(false) // Only one version active at a time
  
  // Risk parameters
  max_position_size_sol   Decimal   @default(0.5) @db.Decimal(20, 9) // Max SOL per position
  max_portfolio_exposure  Decimal   @default(0.3) @db.Decimal(5, 4) // Max % of portfolio in trades
  max_single_loss_sol     Decimal   @default(0.1) @db.Decimal(20, 9) // Max loss per trade
  stop_loss_percentage    Decimal   @default(0.15) @db.Decimal(5, 4) // Default stop loss 15%
  take_profit_percentage  Decimal   @default(0.3) @db.Decimal(5, 4) // Default take profit 30%
  
  // Decision thresholds
  min_confidence_score    Decimal   @default(0.65) @db.Decimal(5, 4) // Min confidence to trade
  min_liquidity_usd       Decimal   @default(50000) @db.Decimal(20, 2) // Min liquidity requirement
  min_volume_24h_usd      Decimal   @default(10000) @db.Decimal(20, 2) // Min 24h volume
  max_price_impact        Decimal   @default(0.02) @db.Decimal(5, 4) // Max acceptable price impact
  
  // Timing parameters
  scan_interval_seconds   Int       @default(300) // How often to scan (5 min)
  decision_cooldown_minutes Int     @default(30) // Min time between decisions on same token
  max_hold_duration_hours Int       @default(72) // Max time to hold position
  
  // Strategy weights
  technical_weight        Decimal   @default(0.4) @db.Decimal(5, 4)
  social_weight           Decimal   @default(0.3) @db.Decimal(5, 4)
  fundamental_weight      Decimal   @default(0.2) @db.Decimal(5, 4)
  risk_weight             Decimal   @default(0.1) @db.Decimal(5, 4)
  
  // Circuit breakers
  max_daily_trades        Int       @default(10)
  max_daily_loss_sol      Decimal   @default(1.0) @db.Decimal(20, 9)
  max_consecutive_losses  Int       @default(3)
  pause_on_circuit_break  Boolean   @default(true)
  
  // Performance triggers for adjustment
  min_win_rate            Decimal   @default(0.4) @db.Decimal(5, 4) // Below this, reduce confidence threshold
  target_sharpe_ratio     Decimal   @default(1.5) @db.Decimal(10, 4) // Target risk-adjusted return
  
  // Metadata
  description             String?   @db.Text
  created_by              String    @default("system") @db.VarChar(100)
  performance_stats       Json?     @default("{}") // Historical performance with these params
  
  // Timestamps
  created_at              DateTime  @default(now()) @db.Timestamptz(6)
  activated_at            DateTime? @db.Timestamptz(6)
  deactivated_at          DateTime? @db.Timestamptz(6)
  
  @@index([is_active, version])
  @@map("ai_strategy_parameters")
}
