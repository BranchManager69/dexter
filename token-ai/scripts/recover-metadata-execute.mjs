#!/usr/bin/env node

// Script to actually recover and update metadata in analysis reports
// Uses the recovery plan generated by the dry run

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ANALYSIS_DIR = path.join(__dirname, '../reports/ai-token-analyses');
const PLAN_PATH = path.join(__dirname, 'metadata-recovery-plan.json');

// Load the recovery plan
if (!fs.existsSync(PLAN_PATH)) {
  console.error('âŒ No recovery plan found. Run recover-metadata-dry-run.mjs first.');
  process.exit(1);
}

const plan = JSON.parse(fs.readFileSync(PLAN_PATH, 'utf8'));
console.log(`ğŸ“‹ Loaded recovery plan with ${plan.length} reports to fix\n`);

// Ask for confirmation
console.log('âš ï¸  WARNING: This will modify', plan.length, 'analysis report files.');
console.log('   Make sure you have a backup if needed.');
console.log('\nReports to be updated:');
plan.slice(0, 5).forEach(p => console.log(`  - ${p.analysisFile}`));
if (plan.length > 5) console.log(`  ... and ${plan.length - 5} more`);

console.log('\nğŸ”§ Starting recovery process...\n');

let updated = 0;
let failed = 0;

for (const item of plan) {
  try {
    const analysisPath = path.join(ANALYSIS_DIR, item.analysisFile);
    
    // Read current analysis
    const content = fs.readFileSync(analysisPath, 'utf8');
    const analysis = JSON.parse(content);
    
    // Prepare the enhanced market data
    const enhancedMarket = {
      // Preserve existing fields
      ...(analysis.metadata?.market || {}),
      
      // Add recovered data
      price: item.recoveredData.price,
      vol1h: item.recoveredData.vol1h,
      vol24h: item.recoveredData.vol24h,
      volume24h: item.recoveredData.vol24h, // Ensure both field names work
      
      // Add nested structure with full token info
      top_pool: {
        chain: item.recoveredData.chain,
        dex: item.recoveredData.dex,
        baseToken: {
          address: item.mint,
          symbol: item.recoveredData.baseTokenSymbol || item.recoveredData.symbol,
          name: item.recoveredData.baseTokenName || item.recoveredData.name
        }
      }
    };
    
    // Update the analysis
    if (!analysis.metadata) analysis.metadata = {};
    analysis.metadata.market = enhancedMarket;
    
    // Also add symbol/name at root level for easier access
    if (item.recoveredData.symbol) {
      analysis.metadata.symbol = item.recoveredData.symbol;
    }
    if (item.recoveredData.name) {
      analysis.metadata.name = item.recoveredData.name;
    }
    
    // Create backup
    const backupPath = analysisPath + '.backup-' + Date.now();
    fs.writeFileSync(backupPath, content);
    
    // Write updated analysis
    fs.writeFileSync(analysisPath, JSON.stringify(analysis, null, 2));
    
    updated++;
    console.log(`âœ… Updated: ${item.analysisFile}`);
    console.log(`   Added: ${item.recoveredData.symbol} (${item.recoveredData.name})`);
    console.log(`   Backup: ${path.basename(backupPath)}\n`);
    
  } catch (error) {
    failed++;
    console.error(`âŒ Failed to update ${item.analysisFile}: ${error.message}\n`);
  }
}

console.log('=' .repeat(60));
console.log('\nğŸ“Š RECOVERY COMPLETE\n');
console.log(`âœ… Successfully updated: ${updated} reports`);
console.log(`âŒ Failed: ${failed} reports`);

if (updated > 0) {
  console.log('\nğŸ’¾ All original files backed up with .backup-<timestamp> extension');
  console.log('   To restore: rename .backup file to original name');
}

// Report on the 2 unrecoverable files
console.log('\nğŸ“ Note about unrecoverable reports:');
console.log('   2 reports (HM1VvScq tokens) could not be recovered.');
console.log('   Options:');
console.log('   1. Re-run analysis for these tokens to get fresh data');
console.log('   2. Leave as-is (they have minimal metadata)');
console.log('   3. Manually search for orchestrator data by token address');